{"body_character":"/*\n * Copyright (c) 2015 PLUMgrid, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <algorithm>\n#include <fcntl.h>\n#include <ftw.h>\n#include <map>\n#include <stdio.h>\n#include <string>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <vector>\n#include <linux/bpf.h>\n\n#include <llvm/ADT/STLExtras.h>\n#include <llvm/ExecutionEngine/MCJIT.h>\n#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n#include <llvm/IRReader/IRReader.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/IRPrintingPasses.h>\n#include <llvm/IR/LegacyPassManager.h>\n#include <llvm/IR/LLVMContext.h>\n#include <llvm/IR/Module.h>\n#include <llvm/IR/Verifier.h>\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/SourceMgr.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/Transforms/IPO.h>\n#include <llvm/Transforms/IPO/PassManagerBuilder.h>\n#include <llvm-c/Transforms/IPO.h>\n\n#include \"exception.h\"\n#include \"frontends/b/loader.h\"\n#include \"frontends/clang/loader.h\"\n#include \"frontends/clang/b_frontend_action.h\"\n#include \"bpf_module.h\"\n#include \"exported_files.h\"\n#include \"kbuild_helper.h\"\n#include \"shared_table.h\"\n#include \"libbpf.h\"\n\nnamespace ebpf {\n\nusing std::get;\nusing std::make_tuple;\nusing std::map;\nusing std::move;\nusing std::string;\nusing std::tuple;\nusing std::unique_ptr;\nusing std::vector;\nusing namespace llvm;\n\ntypedef int (* sscanf_fn) (const char *, void *);\ntypedef int (* snprintf_fn) (char *, size_t, const void *);\n\nconst string BPFModule::FN_PREFIX = BPF_FN_PREFIX;\n\n// Snooping  to remember the sections as the JIT creates them\nclass MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n};\n\nBPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}\n\nBPFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}\n\nstatic void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf\");\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf\", mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}\n\n// recursive helper to capture the arguments\nstatic void parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ \";\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"}\";\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ \";\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"]\";\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x\";\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh\";\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h\";\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%\";\n    else\n      *fmt += \"%l\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}\n\nFunction * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader\" + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n\", vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf\");\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf\", mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then\", fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}\n\nFunction * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer\" + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len\");\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n\", vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf\");\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf\", mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}\n\nunique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n  return engine;\n}\n\n// load an entire c file as a module\nint BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}\n\n// NOTE: this is a duplicate of the above, but planning to deprecate if we\n// settle on clang as the frontend\n\n// Load in a pre-built list of functions into the initial Module object, then\n// build an ExecutionEngine.\nint BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}\n\nint BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf\", *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}\n\nvoid BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}\n\nint BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}\n\nint BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128\");\n  mod->setTargetTriple(\"bpf-pc-linux\");\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf\");\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}\n\nsize_t BPFModule::num_functions() const {\n  return function_names_.size();\n}\n\nconst char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}\n\nuint8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}\n\nuint8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}\n\nsize_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}\n\nsize_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}\n\nchar * BPFModule::license() const {\n  auto section = sections_.find(\"license\");\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}\n\nunsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version\");\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}\n\nsize_t BPFModule::num_tables() const {\n  return tables_->size();\n}\n\nsize_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}\n\nint BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}\n\nint BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}\n\nint BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}\n\nint BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}\n\nsize_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}\n\nsize_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}\n\nconst char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}\n\nconst char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}\n\nconst char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}\n\nconst char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}\n\nconst char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}\nsize_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}\nsize_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}\n\nsize_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}\nsize_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}\n\nstruct TableIterator {\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n};\n\nint BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\n// load a B file, which comes in two parts\nint BPFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n\");\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h\");\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h\");\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C file\nint BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C text string\nint BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n} // namespace ebpf\n","children":[{"body_character":"/**\n * Copyright (c) 2015 PLUMgrid, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *","children":[],"id":"0","children_ids":[],"type":"comment","name":null,"body":"/*\n * Copyright (c) 2015 PLUMgrid, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */","line_start":1,"line_end":15,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":1,"start_statement_line_end":1,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":15,"end_statement_line_end":15,"end_statement_line_in_start":15,"end_statement_line_in_end":15,"char_start":0,"start_statement_char_start":0,"start_statement_char_end":2,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":597,"end_statement_char_start":595,"end_statement_char_end":597,"end_statement_char_in_start":595,"end_statement_char_in_end":597},{"body_character":"#include <algorithm>\ninclude <algorithm>\n","children":[],"id":"1","children_ids":[],"type":"include","name":"<algorithm>","body":"#include <algorithm>","line_start":16,"line_end":16,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <algorithm>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <algorithm>\n","start_statement_line_start":16,"start_statement_line_end":17,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":16,"end_statement_line_end":16,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":598,"start_statement_char_start":598,"start_statement_char_end":619,"start_statement_char_in_start":0,"start_statement_char_in_end":21,"char_end":618,"end_statement_char_start":618,"end_statement_char_end":618,"end_statement_char_in_start":20,"end_statement_char_in_end":20},{"body_character":"#include <fcntl.h>\ninclude <fcntl.h>\n","children":[],"id":"2","children_ids":[],"type":"include","name":"<fcntl.h>","body":"#include <fcntl.h>","line_start":17,"line_end":17,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <fcntl.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <fcntl.h>\n","start_statement_line_start":17,"start_statement_line_end":18,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":17,"end_statement_line_end":17,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":619,"start_statement_char_start":619,"start_statement_char_end":638,"start_statement_char_in_start":0,"start_statement_char_in_end":19,"char_end":637,"end_statement_char_start":637,"end_statement_char_end":637,"end_statement_char_in_start":18,"end_statement_char_in_end":18},{"body_character":"#include <ftw.h>\ninclude <ftw.h>\n","children":[],"id":"3","children_ids":[],"type":"include","name":"<ftw.h>","body":"#include <ftw.h>","line_start":18,"line_end":18,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <ftw.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <ftw.h>\n","start_statement_line_start":18,"start_statement_line_end":19,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":18,"end_statement_line_end":18,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":638,"start_statement_char_start":638,"start_statement_char_end":655,"start_statement_char_in_start":0,"start_statement_char_in_end":17,"char_end":654,"end_statement_char_start":654,"end_statement_char_end":654,"end_statement_char_in_start":16,"end_statement_char_in_end":16},{"body_character":"#include <map>\ninclude <map>\n","children":[],"id":"4","children_ids":[],"type":"include","name":"<map>","body":"#include <map>","line_start":19,"line_end":19,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <map>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <map>\n","start_statement_line_start":19,"start_statement_line_end":20,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":19,"end_statement_line_end":19,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":655,"start_statement_char_start":655,"start_statement_char_end":670,"start_statement_char_in_start":0,"start_statement_char_in_end":15,"char_end":669,"end_statement_char_start":669,"end_statement_char_end":669,"end_statement_char_in_start":14,"end_statement_char_in_end":14},{"body_character":"#include <stdio.h>\ninclude <stdio.h>\n","children":[],"id":"5","children_ids":[],"type":"include","name":"<stdio.h>","body":"#include <stdio.h>","line_start":20,"line_end":20,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <stdio.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <stdio.h>\n","start_statement_line_start":20,"start_statement_line_end":21,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":20,"end_statement_line_end":20,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":670,"start_statement_char_start":670,"start_statement_char_end":689,"start_statement_char_in_start":0,"start_statement_char_in_end":19,"char_end":688,"end_statement_char_start":688,"end_statement_char_end":688,"end_statement_char_in_start":18,"end_statement_char_in_end":18},{"body_character":"#include <string>\ninclude <string>\n","children":[],"id":"6","children_ids":[],"type":"include","name":"<string>","body":"#include <string>","line_start":21,"line_end":21,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <string>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <string>\n","start_statement_line_start":21,"start_statement_line_end":22,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":21,"end_statement_line_end":21,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":689,"start_statement_char_start":689,"start_statement_char_end":707,"start_statement_char_in_start":0,"start_statement_char_in_end":18,"char_end":706,"end_statement_char_start":706,"end_statement_char_end":706,"end_statement_char_in_start":17,"end_statement_char_in_end":17},{"body_character":"#include <sys/stat.h>\ninclude <sys/stat.h>\n","children":[],"id":"7","children_ids":[],"type":"include","name":"<sys/stat.h>","body":"#include <sys/stat.h>","line_start":22,"line_end":22,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <sys/stat.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <sys/stat.h>\n","start_statement_line_start":22,"start_statement_line_end":23,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":22,"end_statement_line_end":22,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":707,"start_statement_char_start":707,"start_statement_char_end":729,"start_statement_char_in_start":0,"start_statement_char_in_end":22,"char_end":728,"end_statement_char_start":728,"end_statement_char_end":728,"end_statement_char_in_start":21,"end_statement_char_in_end":21},{"body_character":"#include <sys/utsname.h>\ninclude <sys/utsname.h>\n","children":[],"id":"8","children_ids":[],"type":"include","name":"<sys/utsname.h>","body":"#include <sys/utsname.h>","line_start":23,"line_end":23,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <sys/utsname.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <sys/utsname.h>\n","start_statement_line_start":23,"start_statement_line_end":24,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":23,"end_statement_line_end":23,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":729,"start_statement_char_start":729,"start_statement_char_end":754,"start_statement_char_in_start":0,"start_statement_char_in_end":25,"char_end":753,"end_statement_char_start":753,"end_statement_char_end":753,"end_statement_char_in_start":24,"end_statement_char_in_end":24},{"body_character":"#include <unistd.h>\ninclude <unistd.h>\n","children":[],"id":"9","children_ids":[],"type":"include","name":"<unistd.h>","body":"#include <unistd.h>","line_start":24,"line_end":24,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <unistd.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <unistd.h>\n","start_statement_line_start":24,"start_statement_line_end":25,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":24,"end_statement_line_end":24,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":754,"start_statement_char_start":754,"start_statement_char_end":774,"start_statement_char_in_start":0,"start_statement_char_in_end":20,"char_end":773,"end_statement_char_start":773,"end_statement_char_end":773,"end_statement_char_in_start":19,"end_statement_char_in_end":19},{"body_character":"#include <vector>\ninclude <vector>\n","children":[],"id":"10","children_ids":[],"type":"include","name":"<vector>","body":"#include <vector>","line_start":25,"line_end":25,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <vector>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <vector>\n","start_statement_line_start":25,"start_statement_line_end":26,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":25,"end_statement_line_end":25,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":774,"start_statement_char_start":774,"start_statement_char_end":792,"start_statement_char_in_start":0,"start_statement_char_in_end":18,"char_end":791,"end_statement_char_start":791,"end_statement_char_end":791,"end_statement_char_in_start":17,"end_statement_char_in_end":17},{"body_character":"#include <linux/bpf.h>\ninclude <linux/bpf.h>\n","children":[],"id":"11","children_ids":[],"type":"include","name":"<linux/bpf.h>","body":"#include <linux/bpf.h>","line_start":26,"line_end":26,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <linux/bpf.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <linux/bpf.h>\n","start_statement_line_start":26,"start_statement_line_end":27,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":26,"end_statement_line_end":26,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":792,"start_statement_char_start":792,"start_statement_char_end":815,"start_statement_char_in_start":0,"start_statement_char_in_end":23,"char_end":814,"end_statement_char_start":814,"end_statement_char_end":814,"end_statement_char_in_start":22,"end_statement_char_in_end":22},{"body_character":"#include <llvm/ADT/STLExtras.h>\ninclude <llvm/ADT/STLExtras.h>\n","children":[],"id":"12","children_ids":[],"type":"include","name":"<llvm/ADT/STLExtras.h>","body":"#include <llvm/ADT/STLExtras.h>","line_start":28,"line_end":28,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/ADT/STLExtras.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/ADT/STLExtras.h>\n","start_statement_line_start":28,"start_statement_line_end":29,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":28,"end_statement_line_end":28,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":816,"start_statement_char_start":816,"start_statement_char_end":848,"start_statement_char_in_start":0,"start_statement_char_in_end":32,"char_end":847,"end_statement_char_start":847,"end_statement_char_end":847,"end_statement_char_in_start":31,"end_statement_char_in_end":31},{"body_character":"#include <llvm/ExecutionEngine/MCJIT.h>\ninclude <llvm/ExecutionEngine/MCJIT.h>\n","children":[],"id":"13","children_ids":[],"type":"include","name":"<llvm/ExecutionEngine/MCJIT.h>","body":"#include <llvm/ExecutionEngine/MCJIT.h>","line_start":29,"line_end":29,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/ExecutionEngine/MCJIT.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/ExecutionEngine/MCJIT.h>\n","start_statement_line_start":29,"start_statement_line_end":30,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":29,"end_statement_line_end":29,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":848,"start_statement_char_start":848,"start_statement_char_end":888,"start_statement_char_in_start":0,"start_statement_char_in_end":40,"char_end":887,"end_statement_char_start":887,"end_statement_char_end":887,"end_statement_char_in_start":39,"end_statement_char_in_end":39},{"body_character":"#include <llvm/ExecutionEngine/SectionMemoryManager.h>\ninclude <llvm/ExecutionEngine/SectionMemoryManager.h>\n","children":[],"id":"14","children_ids":[],"type":"include","name":"<llvm/ExecutionEngine/SectionMemoryManager.h>","body":"#include <llvm/ExecutionEngine/SectionMemoryManager.h>","line_start":30,"line_end":30,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n","start_statement_line_start":30,"start_statement_line_end":31,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":30,"end_statement_line_end":30,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":888,"start_statement_char_start":888,"start_statement_char_end":943,"start_statement_char_in_start":0,"start_statement_char_in_end":55,"char_end":942,"end_statement_char_start":942,"end_statement_char_end":942,"end_statement_char_in_start":54,"end_statement_char_in_end":54},{"body_character":"#include <llvm/IRReader/IRReader.h>\ninclude <llvm/IRReader/IRReader.h>\n","children":[],"id":"15","children_ids":[],"type":"include","name":"<llvm/IRReader/IRReader.h>","body":"#include <llvm/IRReader/IRReader.h>","line_start":31,"line_end":31,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IRReader/IRReader.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IRReader/IRReader.h>\n","start_statement_line_start":31,"start_statement_line_end":32,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":31,"end_statement_line_end":31,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":943,"start_statement_char_start":943,"start_statement_char_end":979,"start_statement_char_in_start":0,"start_statement_char_in_end":36,"char_end":978,"end_statement_char_start":978,"end_statement_char_end":978,"end_statement_char_in_start":35,"end_statement_char_in_end":35},{"body_character":"#include <llvm/IR/IRBuilder.h>\ninclude <llvm/IR/IRBuilder.h>\n","children":[],"id":"16","children_ids":[],"type":"include","name":"<llvm/IR/IRBuilder.h>","body":"#include <llvm/IR/IRBuilder.h>","line_start":32,"line_end":32,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/IRBuilder.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/IRBuilder.h>\n","start_statement_line_start":32,"start_statement_line_end":33,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":32,"end_statement_line_end":32,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":979,"start_statement_char_start":979,"start_statement_char_end":1010,"start_statement_char_in_start":0,"start_statement_char_in_end":31,"char_end":1009,"end_statement_char_start":1009,"end_statement_char_end":1009,"end_statement_char_in_start":30,"end_statement_char_in_end":30},{"body_character":"#include <llvm/IR/IRPrintingPasses.h>\ninclude <llvm/IR/IRPrintingPasses.h>\n","children":[],"id":"17","children_ids":[],"type":"include","name":"<llvm/IR/IRPrintingPasses.h>","body":"#include <llvm/IR/IRPrintingPasses.h>","line_start":33,"line_end":33,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/IRPrintingPasses.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/IRPrintingPasses.h>\n","start_statement_line_start":33,"start_statement_line_end":34,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":33,"end_statement_line_end":33,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1010,"start_statement_char_start":1010,"start_statement_char_end":1048,"start_statement_char_in_start":0,"start_statement_char_in_end":38,"char_end":1047,"end_statement_char_start":1047,"end_statement_char_end":1047,"end_statement_char_in_start":37,"end_statement_char_in_end":37},{"body_character":"#include <llvm/IR/LegacyPassManager.h>\ninclude <llvm/IR/LegacyPassManager.h>\n","children":[],"id":"18","children_ids":[],"type":"include","name":"<llvm/IR/LegacyPassManager.h>","body":"#include <llvm/IR/LegacyPassManager.h>","line_start":34,"line_end":34,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/LegacyPassManager.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/LegacyPassManager.h>\n","start_statement_line_start":34,"start_statement_line_end":35,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":34,"end_statement_line_end":34,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1048,"start_statement_char_start":1048,"start_statement_char_end":1087,"start_statement_char_in_start":0,"start_statement_char_in_end":39,"char_end":1086,"end_statement_char_start":1086,"end_statement_char_end":1086,"end_statement_char_in_start":38,"end_statement_char_in_end":38},{"body_character":"#include <llvm/IR/LLVMContext.h>\ninclude <llvm/IR/LLVMContext.h>\n","children":[],"id":"19","children_ids":[],"type":"include","name":"<llvm/IR/LLVMContext.h>","body":"#include <llvm/IR/LLVMContext.h>","line_start":35,"line_end":35,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/LLVMContext.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/LLVMContext.h>\n","start_statement_line_start":35,"start_statement_line_end":36,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":35,"end_statement_line_end":35,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1087,"start_statement_char_start":1087,"start_statement_char_end":1120,"start_statement_char_in_start":0,"start_statement_char_in_end":33,"char_end":1119,"end_statement_char_start":1119,"end_statement_char_end":1119,"end_statement_char_in_start":32,"end_statement_char_in_end":32},{"body_character":"#include <llvm/IR/Module.h>\ninclude <llvm/IR/Module.h>\n","children":[],"id":"20","children_ids":[],"type":"include","name":"<llvm/IR/Module.h>","body":"#include <llvm/IR/Module.h>","line_start":36,"line_end":36,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/Module.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/Module.h>\n","start_statement_line_start":36,"start_statement_line_end":37,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":36,"end_statement_line_end":36,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1120,"start_statement_char_start":1120,"start_statement_char_end":1148,"start_statement_char_in_start":0,"start_statement_char_in_end":28,"char_end":1147,"end_statement_char_start":1147,"end_statement_char_end":1147,"end_statement_char_in_start":27,"end_statement_char_in_end":27},{"body_character":"#include <llvm/IR/Verifier.h>\ninclude <llvm/IR/Verifier.h>\n","children":[],"id":"21","children_ids":[],"type":"include","name":"<llvm/IR/Verifier.h>","body":"#include <llvm/IR/Verifier.h>","line_start":37,"line_end":37,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/IR/Verifier.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/IR/Verifier.h>\n","start_statement_line_start":37,"start_statement_line_end":38,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":37,"end_statement_line_end":37,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1148,"start_statement_char_start":1148,"start_statement_char_end":1178,"start_statement_char_in_start":0,"start_statement_char_in_end":30,"char_end":1177,"end_statement_char_start":1177,"end_statement_char_end":1177,"end_statement_char_in_start":29,"end_statement_char_in_end":29},{"body_character":"#include <llvm/Object/ObjectFile.h>\ninclude <llvm/Object/ObjectFile.h>\n","children":[],"id":"22","children_ids":[],"type":"include","name":"<llvm/Object/ObjectFile.h>","body":"#include <llvm/Object/ObjectFile.h>","line_start":38,"line_end":38,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Object/ObjectFile.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Object/ObjectFile.h>\n","start_statement_line_start":38,"start_statement_line_end":39,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":38,"end_statement_line_end":38,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1178,"start_statement_char_start":1178,"start_statement_char_end":1214,"start_statement_char_in_start":0,"start_statement_char_in_end":36,"char_end":1213,"end_statement_char_start":1213,"end_statement_char_end":1213,"end_statement_char_in_start":35,"end_statement_char_in_end":35},{"body_character":"#include <llvm/Support/FormattedStream.h>\ninclude <llvm/Support/FormattedStream.h>\n","children":[],"id":"23","children_ids":[],"type":"include","name":"<llvm/Support/FormattedStream.h>","body":"#include <llvm/Support/FormattedStream.h>","line_start":39,"line_end":39,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Support/FormattedStream.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Support/FormattedStream.h>\n","start_statement_line_start":39,"start_statement_line_end":40,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":39,"end_statement_line_end":39,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1214,"start_statement_char_start":1214,"start_statement_char_end":1256,"start_statement_char_in_start":0,"start_statement_char_in_end":42,"char_end":1255,"end_statement_char_start":1255,"end_statement_char_end":1255,"end_statement_char_in_start":41,"end_statement_char_in_end":41},{"body_character":"#include <llvm/Support/Host.h>\ninclude <llvm/Support/Host.h>\n","children":[],"id":"24","children_ids":[],"type":"include","name":"<llvm/Support/Host.h>","body":"#include <llvm/Support/Host.h>","line_start":40,"line_end":40,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Support/Host.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Support/Host.h>\n","start_statement_line_start":40,"start_statement_line_end":41,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":40,"end_statement_line_end":40,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1256,"start_statement_char_start":1256,"start_statement_char_end":1287,"start_statement_char_in_start":0,"start_statement_char_in_end":31,"char_end":1286,"end_statement_char_start":1286,"end_statement_char_end":1286,"end_statement_char_in_start":30,"end_statement_char_in_end":30},{"body_character":"#include <llvm/Support/SourceMgr.h>\ninclude <llvm/Support/SourceMgr.h>\n","children":[],"id":"25","children_ids":[],"type":"include","name":"<llvm/Support/SourceMgr.h>","body":"#include <llvm/Support/SourceMgr.h>","line_start":41,"line_end":41,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Support/SourceMgr.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Support/SourceMgr.h>\n","start_statement_line_start":41,"start_statement_line_end":42,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":41,"end_statement_line_end":41,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1287,"start_statement_char_start":1287,"start_statement_char_end":1323,"start_statement_char_in_start":0,"start_statement_char_in_end":36,"char_end":1322,"end_statement_char_start":1322,"end_statement_char_end":1322,"end_statement_char_in_start":35,"end_statement_char_in_end":35},{"body_character":"#include <llvm/Support/TargetSelect.h>\ninclude <llvm/Support/TargetSelect.h>\n","children":[],"id":"26","children_ids":[],"type":"include","name":"<llvm/Support/TargetSelect.h>","body":"#include <llvm/Support/TargetSelect.h>","line_start":42,"line_end":42,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Support/TargetSelect.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Support/TargetSelect.h>\n","start_statement_line_start":42,"start_statement_line_end":43,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":42,"end_statement_line_end":42,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1323,"start_statement_char_start":1323,"start_statement_char_end":1362,"start_statement_char_in_start":0,"start_statement_char_in_end":39,"char_end":1361,"end_statement_char_start":1361,"end_statement_char_end":1361,"end_statement_char_in_start":38,"end_statement_char_in_end":38},{"body_character":"#include <llvm/Transforms/IPO.h>\ninclude <llvm/Transforms/IPO.h>\n","children":[],"id":"27","children_ids":[],"type":"include","name":"<llvm/Transforms/IPO.h>","body":"#include <llvm/Transforms/IPO.h>","line_start":43,"line_end":43,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Transforms/IPO.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Transforms/IPO.h>\n","start_statement_line_start":43,"start_statement_line_end":44,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":43,"end_statement_line_end":43,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1362,"start_statement_char_start":1362,"start_statement_char_end":1395,"start_statement_char_in_start":0,"start_statement_char_in_end":33,"char_end":1394,"end_statement_char_start":1394,"end_statement_char_end":1394,"end_statement_char_in_start":32,"end_statement_char_in_end":32},{"body_character":"#include <llvm/Transforms/IPO/PassManagerBuilder.h>\ninclude <llvm/Transforms/IPO/PassManagerBuilder.h>\n","children":[],"id":"28","children_ids":[],"type":"include","name":"<llvm/Transforms/IPO/PassManagerBuilder.h>","body":"#include <llvm/Transforms/IPO/PassManagerBuilder.h>","line_start":44,"line_end":44,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include <llvm/Transforms/IPO/PassManagerBuilder.h>\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include <llvm/Transforms/IPO/PassManagerBuilder.h>\n","start_statement_line_start":44,"start_statement_line_end":45,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":44,"end_statement_line_end":44,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1395,"start_statement_char_start":1395,"start_statement_char_end":1447,"start_statement_char_in_start":0,"start_statement_char_in_end":52,"char_end":1446,"end_statement_char_start":1446,"end_statement_char_end":1446,"end_statement_char_in_start":51,"end_statement_char_in_end":51},{"body_character":"#include \"exception.h\"\ninclude \"exception.h\n","children":[],"id":"29","children_ids":[],"type":"include","name":"\"exception.h\"","body":"#include \"exception.h\"","line_start":47,"line_end":47,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"exception.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"exception.h\"\n","start_statement_line_start":47,"start_statement_line_end":48,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":47,"end_statement_line_end":47,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1483,"start_statement_char_start":1483,"start_statement_char_end":1506,"start_statement_char_in_start":0,"start_statement_char_in_end":23,"char_end":1505,"end_statement_char_start":1505,"end_statement_char_end":1505,"end_statement_char_in_start":22,"end_statement_char_in_end":22},{"body_character":"#include \"frontends/b/loader.h\"\ninclude \"frontends/b/loader.h\n","children":[],"id":"30","children_ids":[],"type":"include","name":"\"frontends/b/loader.h\"","body":"#include \"frontends/b/loader.h\"","line_start":48,"line_end":48,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"frontends/b/loader.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"frontends/b/loader.h\"\n","start_statement_line_start":48,"start_statement_line_end":49,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":48,"end_statement_line_end":48,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1506,"start_statement_char_start":1506,"start_statement_char_end":1538,"start_statement_char_in_start":0,"start_statement_char_in_end":32,"char_end":1537,"end_statement_char_start":1537,"end_statement_char_end":1537,"end_statement_char_in_start":31,"end_statement_char_in_end":31},{"body_character":"#include \"frontends/clang/loader.h\"\ninclude \"frontends/clang/loader.h\n","children":[],"id":"31","children_ids":[],"type":"include","name":"\"frontends/clang/loader.h\"","body":"#include \"frontends/clang/loader.h\"","line_start":49,"line_end":49,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"frontends/clang/loader.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"frontends/clang/loader.h\"\n","start_statement_line_start":49,"start_statement_line_end":50,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":49,"end_statement_line_end":49,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1538,"start_statement_char_start":1538,"start_statement_char_end":1574,"start_statement_char_in_start":0,"start_statement_char_in_end":36,"char_end":1573,"end_statement_char_start":1573,"end_statement_char_end":1573,"end_statement_char_in_start":35,"end_statement_char_in_end":35},{"body_character":"#include \"frontends/clang/b_frontend_action.h\"\ninclude \"frontends/clang/b_frontend_action.h\n","children":[],"id":"32","children_ids":[],"type":"include","name":"\"frontends/clang/b_frontend_action.h\"","body":"#include \"frontends/clang/b_frontend_action.h\"","line_start":50,"line_end":50,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"frontends/clang/b_frontend_action.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"frontends/clang/b_frontend_action.h\"\n","start_statement_line_start":50,"start_statement_line_end":51,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":50,"end_statement_line_end":50,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1574,"start_statement_char_start":1574,"start_statement_char_end":1621,"start_statement_char_in_start":0,"start_statement_char_in_end":47,"char_end":1620,"end_statement_char_start":1620,"end_statement_char_end":1620,"end_statement_char_in_start":46,"end_statement_char_in_end":46},{"body_character":"#include \"bpf_module.h\"\ninclude \"bpf_module.h\n","children":[],"id":"33","children_ids":[],"type":"include","name":"\"bpf_module.h\"","body":"#include \"bpf_module.h\"","line_start":51,"line_end":51,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"bpf_module.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"bpf_module.h\"\n","start_statement_line_start":51,"start_statement_line_end":52,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":51,"end_statement_line_end":51,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1621,"start_statement_char_start":1621,"start_statement_char_end":1645,"start_statement_char_in_start":0,"start_statement_char_in_end":24,"char_end":1644,"end_statement_char_start":1644,"end_statement_char_end":1644,"end_statement_char_in_start":23,"end_statement_char_in_end":23},{"body_character":"#include \"exported_files.h\"\ninclude \"exported_files.h\n","children":[],"id":"34","children_ids":[],"type":"include","name":"\"exported_files.h\"","body":"#include \"exported_files.h\"","line_start":52,"line_end":52,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"exported_files.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"exported_files.h\"\n","start_statement_line_start":52,"start_statement_line_end":53,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":52,"end_statement_line_end":52,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1645,"start_statement_char_start":1645,"start_statement_char_end":1673,"start_statement_char_in_start":0,"start_statement_char_in_end":28,"char_end":1672,"end_statement_char_start":1672,"end_statement_char_end":1672,"end_statement_char_in_start":27,"end_statement_char_in_end":27},{"body_character":"#include \"kbuild_helper.h\"\ninclude \"kbuild_helper.h\n","children":[],"id":"35","children_ids":[],"type":"include","name":"\"kbuild_helper.h\"","body":"#include \"kbuild_helper.h\"","line_start":53,"line_end":53,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"kbuild_helper.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"kbuild_helper.h\"\n","start_statement_line_start":53,"start_statement_line_end":54,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":53,"end_statement_line_end":53,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1673,"start_statement_char_start":1673,"start_statement_char_end":1700,"start_statement_char_in_start":0,"start_statement_char_in_end":27,"char_end":1699,"end_statement_char_start":1699,"end_statement_char_end":1699,"end_statement_char_in_start":26,"end_statement_char_in_end":26},{"body_character":"#include \"shared_table.h\"\ninclude \"shared_table.h\n","children":[],"id":"36","children_ids":[],"type":"include","name":"\"shared_table.h\"","body":"#include \"shared_table.h\"","line_start":54,"line_end":54,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"shared_table.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"shared_table.h\"\n","start_statement_line_start":54,"start_statement_line_end":55,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":54,"end_statement_line_end":54,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1700,"start_statement_char_start":1700,"start_statement_char_end":1726,"start_statement_char_in_start":0,"start_statement_char_in_end":26,"char_end":1725,"end_statement_char_start":1725,"end_statement_char_end":1725,"end_statement_char_in_start":25,"end_statement_char_in_end":25},{"body_character":"#include \"libbpf.h\"\ninclude \"libbpf.h\n","children":[],"id":"37","children_ids":[],"type":"include","name":"\"libbpf.h\"","body":"#include \"libbpf.h\"","line_start":55,"line_end":55,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"#include \"libbpf.h\"\n","end_statement":"","start_statement_regexp":"/#include\\s+([A-Za-z0-9_\\.<>\\/\\\\\\t \"]+)\\n/","start_statement_matched":"#include \"libbpf.h\"\n","start_statement_line_start":55,"start_statement_line_end":56,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":55,"end_statement_line_end":55,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1726,"start_statement_char_start":1726,"start_statement_char_end":1746,"start_statement_char_in_start":0,"start_statement_char_in_end":20,"char_end":1745,"end_statement_char_start":1745,"end_statement_char_end":1745,"end_statement_char_in_start":19,"end_statement_char_in_end":19},{"body_character":"namespace ebpf {amespace ebpf {\n\nusing std::get;\nusing std::make_tuple;\nusing std::map;\nusing std::move;\nusing std::string;\nusing std::tuple;\nusing std::unique_ptr;\nusing std::vector;\nusing namespace llvm;\n\ntypedef int (* sscanf_fn) (const char *, void *);\ntypedef int (* snprintf_fn) (char *, size_t, const void *);\n\nconst string BPFModule::FN_PREFIX = BPF_FN_PREFIX;\n\n// Snooping  to remember the sections as the JIT creates them\nclass MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n};\n\nBPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}\n\nBPFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}\n\nstatic void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf);\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf, mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}\n\n// recursive helper to capture the arguments\nstatic void parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ ;\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"};\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ ;\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"];\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x;\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh;\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h;\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%;\n    else\n      *fmt += \"%l;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}\n\nFunction * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in);\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out);\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry, fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit, fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n, vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf);\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf, mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then, fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}\n\nFunction * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out);\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len);\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in);\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry, fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n, vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf);\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf, mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}\n\nunique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n, err.c_str());\n  return engine;\n}\n\n// load an entire c file as a module\nint BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}\n\n// NOTE: this is a duplicate of the above, but planning to deprecate if we\n// settle on clang as the frontend\n\n// Load in a pre-built list of functions into the initial Module object, then\n// build an ExecutionEngine.\nint BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}\n\nint BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf, *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for  << *key_type << \"\\n;\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for  << *leaf_type << \"\\n;\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for  << *key_type << \"\\n;\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for  << *leaf_type << \"\\n;\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}\n\nvoid BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}\n\nint BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}\n\nint BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128);\n  mod->setTargetTriple(\"bpf-pc-linux);\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf);\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n, err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}\n\nsize_t BPFModule::num_functions() const {\n  return function_names_.size();\n}\n\nconst char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}\n\nuint8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}\n\nuint8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}\n\nsize_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}\n\nsize_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}\n\nchar * BPFModule::license() const {\n  auto section = sections_.find(\"license);\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}\n\nunsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version);\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}\n\nsize_t BPFModule::num_tables() const {\n  return tables_->size();\n}\n\nsize_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}\n\nint BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}\n\nint BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}\n\nint BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}\n\nint BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}\n\nsize_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}\n\nsize_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}\n\nconst char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}\n\nconst char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}\n\nconst char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}\n\nconst char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}\n\nconst char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}\nsize_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}\nsize_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}\n\nsize_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}\nsize_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}\n\nstruct TableIterator {\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n};\n\nint BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf);\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf);\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf);\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf);\n    return -1;\n  }\n  return 0;\n}\n\n// load a B file, which comes in two parts\nint BPFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n);\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h);\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h);\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C file\nint BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n);\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C text string\nint BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n}","children":[{"body_character":"using std::get;sing std::get;","children":[],"id":"39","children_ids":[],"type":"attribute","name":"using std::get","body":"using std::get","line_start":59,"line_end":59,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::get;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::get;","start_statement_line_start":59,"start_statement_line_end":59,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":59,"end_statement_line_end":59,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1765,"start_statement_char_start":1765,"start_statement_char_end":1780,"start_statement_char_in_start":0,"start_statement_char_in_end":15,"char_end":1779,"end_statement_char_start":1779,"end_statement_char_end":1779,"end_statement_char_in_start":14,"end_statement_char_in_end":14},{"body_character":"using std::make_tuple;sing std::make_tuple;","children":[],"id":"40","children_ids":[],"type":"attribute","name":"using std::make_tuple","body":"using std::make_tuple","line_start":60,"line_end":60,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::make_tuple;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::make_tuple;","start_statement_line_start":60,"start_statement_line_end":60,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":60,"end_statement_line_end":60,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1781,"start_statement_char_start":1781,"start_statement_char_end":1803,"start_statement_char_in_start":0,"start_statement_char_in_end":22,"char_end":1802,"end_statement_char_start":1802,"end_statement_char_end":1802,"end_statement_char_in_start":21,"end_statement_char_in_end":21},{"body_character":"using std::map;sing std::map;","children":[],"id":"41","children_ids":[],"type":"attribute","name":"using std::map","body":"using std::map","line_start":61,"line_end":61,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::map;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::map;","start_statement_line_start":61,"start_statement_line_end":61,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":61,"end_statement_line_end":61,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1804,"start_statement_char_start":1804,"start_statement_char_end":1819,"start_statement_char_in_start":0,"start_statement_char_in_end":15,"char_end":1818,"end_statement_char_start":1818,"end_statement_char_end":1818,"end_statement_char_in_start":14,"end_statement_char_in_end":14},{"body_character":"using std::move;sing std::move;","children":[],"id":"42","children_ids":[],"type":"attribute","name":"using std::move","body":"using std::move","line_start":62,"line_end":62,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::move;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::move;","start_statement_line_start":62,"start_statement_line_end":62,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":62,"end_statement_line_end":62,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1820,"start_statement_char_start":1820,"start_statement_char_end":1836,"start_statement_char_in_start":0,"start_statement_char_in_end":16,"char_end":1835,"end_statement_char_start":1835,"end_statement_char_end":1835,"end_statement_char_in_start":15,"end_statement_char_in_end":15},{"body_character":"using std::string;sing std::string;","children":[],"id":"43","children_ids":[],"type":"attribute","name":"using std::string","body":"using std::string","line_start":63,"line_end":63,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::string;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::string;","start_statement_line_start":63,"start_statement_line_end":63,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":63,"end_statement_line_end":63,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1837,"start_statement_char_start":1837,"start_statement_char_end":1855,"start_statement_char_in_start":0,"start_statement_char_in_end":18,"char_end":1854,"end_statement_char_start":1854,"end_statement_char_end":1854,"end_statement_char_in_start":17,"end_statement_char_in_end":17},{"body_character":"using std::tuple;sing std::tuple;","children":[],"id":"44","children_ids":[],"type":"attribute","name":"using std::tuple","body":"using std::tuple","line_start":64,"line_end":64,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::tuple;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::tuple;","start_statement_line_start":64,"start_statement_line_end":64,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":64,"end_statement_line_end":64,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1856,"start_statement_char_start":1856,"start_statement_char_end":1873,"start_statement_char_in_start":0,"start_statement_char_in_end":17,"char_end":1872,"end_statement_char_start":1872,"end_statement_char_end":1872,"end_statement_char_in_start":16,"end_statement_char_in_end":16},{"body_character":"using std::unique_ptr;sing std::unique_ptr;","children":[],"id":"45","children_ids":[],"type":"attribute","name":"using std::unique_ptr","body":"using std::unique_ptr","line_start":65,"line_end":65,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::unique_ptr;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::unique_ptr;","start_statement_line_start":65,"start_statement_line_end":65,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":65,"end_statement_line_end":65,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1874,"start_statement_char_start":1874,"start_statement_char_end":1896,"start_statement_char_in_start":0,"start_statement_char_in_end":22,"char_end":1895,"end_statement_char_start":1895,"end_statement_char_end":1895,"end_statement_char_in_start":21,"end_statement_char_in_end":21},{"body_character":"using std::vector;sing std::vector;","children":[],"id":"46","children_ids":[],"type":"attribute","name":"using std::vector","body":"using std::vector","line_start":66,"line_end":66,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using std::vector;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using std::vector;","start_statement_line_start":66,"start_statement_line_end":66,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":66,"end_statement_line_end":66,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1897,"start_statement_char_start":1897,"start_statement_char_end":1915,"start_statement_char_in_start":0,"start_statement_char_in_end":18,"char_end":1914,"end_statement_char_start":1914,"end_statement_char_end":1914,"end_statement_char_in_start":17,"end_statement_char_in_end":17},{"body_character":"using namespace llvm;sing namespace llvm;","children":[],"id":"47","children_ids":[],"type":"attribute","name":"using namespace llvm","body":"using namespace llvm","line_start":67,"line_end":67,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"using namespace llvm;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"using namespace llvm;","start_statement_line_start":67,"start_statement_line_end":67,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":67,"end_statement_line_end":67,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1916,"start_statement_char_start":1916,"start_statement_char_end":1937,"start_statement_char_in_start":0,"start_statement_char_in_end":21,"char_end":1936,"end_statement_char_start":1936,"end_statement_char_end":1936,"end_statement_char_in_start":20,"end_statement_char_in_end":20},{"body_character":"typedef int (* sscanf_fn) (const char *, void *);ypedef int (* sscanf_fn) (const char *, void *);","children":[],"id":"48","children_ids":[],"type":"attribute","name":"typedef int (* sscanf_fn) (const char *, void *)","body":"typedef int (* sscanf_fn) (const char *, void *)","line_start":69,"line_end":69,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"typedef int (* sscanf_fn) (const char *, void *);","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"typedef int (* sscanf_fn) (const char *, void *);","start_statement_line_start":69,"start_statement_line_end":69,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":69,"end_statement_line_end":69,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1939,"start_statement_char_start":1939,"start_statement_char_end":1988,"start_statement_char_in_start":0,"start_statement_char_in_end":49,"char_end":1987,"end_statement_char_start":1987,"end_statement_char_end":1987,"end_statement_char_in_start":48,"end_statement_char_in_end":48},{"body_character":"typedef int (* snprintf_fn) (char *, size_t, const void *);ypedef int (* snprintf_fn) (char *, size_t, const void *);","children":[],"id":"49","children_ids":[],"type":"attribute","name":"typedef int (* snprintf_fn) (char *, size_t, const void *)","body":"typedef int (* snprintf_fn) (char *, size_t, const void *)","line_start":70,"line_end":70,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"typedef int (* snprintf_fn) (char *, size_t, const void *);","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":"typedef int (* snprintf_fn) (char *, size_t, const void *);","start_statement_line_start":70,"start_statement_line_end":70,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":70,"end_statement_line_end":70,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1989,"start_statement_char_start":1989,"start_statement_char_end":2048,"start_statement_char_in_start":0,"start_statement_char_in_end":59,"char_end":2047,"end_statement_char_start":2047,"end_statement_char_end":2047,"end_statement_char_in_start":58,"end_statement_char_in_end":58},{"body_character":"const string BPFModule::FN_PREFIX =onst string BPFModule::FN_PREFIX = BPF_FN_PREFIX;","children":[],"id":"50","children_ids":[],"type":"attribute-assignment","name":"const string BPFModule::FN_PREFIX ","body":"const string BPFModule::FN_PREFIX = BPF_FN_PREFIX;","line_start":72,"line_end":72,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const string BPFModule::FN_PREFIX =","end_statement":";","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*=/","start_statement_matched":"const string BPFModule::FN_PREFIX =","start_statement_line_start":72,"start_statement_line_end":72,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/;/","end_statement_matched":";","end_statement_line_start":72,"end_statement_line_end":72,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2050,"start_statement_char_start":2050,"start_statement_char_end":2085,"start_statement_char_in_start":0,"start_statement_char_in_end":35,"char_end":2100,"end_statement_char_start":2099,"end_statement_char_end":2100,"end_statement_char_in_start":49,"end_statement_char_in_end":50},{"body_character":"/// Snooping  to remember the sections as the JIT creates them\n","children":[],"id":"51","children_ids":[],"type":"comment","name":null,"body":"// Snooping  to remember the sections as the JIT creates them\n","line_start":74,"line_end":74,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"     ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":74,"start_statement_line_end":74,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":73,"end_statement_line_end":74,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":2102,"start_statement_char_start":2102,"start_statement_char_end":2104,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":2164,"end_statement_char_start":2163,"end_statement_char_end":2164,"end_statement_char_in_start":61,"end_statement_char_in_end":62},{"body_character":"class MyMemoryManager : public SectionMemoryManager {lass MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n}","children":[{"body_character":"public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {ublic:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }","children":[],"id":"53","children_ids":[],"type":"method","name":"MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)","body":"public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }","line_start":76,"line_end":80,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {","start_statement_line_start":76,"start_statement_line_end":79,"start_statement_line_in_start":1,"start_statement_line_in_end":4,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":80,"end_statement_line_end":80,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":2219,"start_statement_char_start":2219,"start_statement_char_end":2336,"start_statement_char_in_start":0,"start_statement_char_in_end":117,"char_end":2340,"end_statement_char_start":2339,"end_statement_char_end":2340,"end_statement_char_in_start":120,"end_statement_char_in_end":121},{"body_character":"~MyMemoryManager() {MyMemoryManager() {}","children":[],"id":"54","children_ids":[],"type":"method","name":"~MyMemoryManager()","body":"~MyMemoryManager() {}","line_start":82,"line_end":82,"line_preserve_start_whitespaces":"   ","line_preserve_end_whitespaces":"","start_statement":"~MyMemoryManager() {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"~MyMemoryManager() {","start_statement_line_start":82,"start_statement_line_end":82,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":82,"end_statement_line_end":82,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2352,"start_statement_char_start":2352,"start_statement_char_end":2372,"start_statement_char_in_start":0,"start_statement_char_in_end":20,"char_end":2373,"end_statement_char_start":2372,"end_statement_char_end":2373,"end_statement_char_in_start":20,"end_statement_char_in_end":21},{"body_character":"uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {int8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }","children":[{"body_character":"///printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n","children":[],"id":"56","children_ids":[],"type":"comment","name":null,"body":"//printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n","line_start":87,"line_end":87,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"    ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":87,"start_statement_line_end":87,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":86,"end_statement_line_end":87,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":2665,"start_statement_char_start":2665,"start_statement_char_end":2667,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":2746,"end_statement_char_start":2745,"end_statement_char_end":2746,"end_statement_char_in_start":80,"end_statement_char_in_end":81},{"body_character":"///       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n","children":[],"id":"57","children_ids":[],"type":"comment","name":null,"body":"//       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n","line_start":88,"line_end":88,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"       ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":88,"start_statement_line_end":88,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":87,"end_statement_line_end":88,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":2750,"start_statement_char_start":2750,"start_statement_char_end":2752,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":2829,"end_statement_char_start":2828,"end_statement_char_end":2829,"end_statement_char_in_start":78,"end_statement_char_in_end":79}],"id":"55","children_ids":["56","57"],"type":"method","name":"*allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName)","body":"uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }","line_start":83,"line_end":91,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {","start_statement_line_start":83,"start_statement_line_end":85,"start_statement_line_in_start":1,"start_statement_line_in_end":3,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":91,"end_statement_line_end":91,"end_statement_line_in_start":9,"end_statement_line_in_end":9,"char_start":2376,"start_statement_char_start":2376,"start_statement_char_end":2556,"start_statement_char_in_start":0,"start_statement_char_in_end":180,"char_end":2911,"end_statement_char_start":2910,"end_statement_char_end":2911,"end_statement_char_in_start":534,"end_statement_char_in_end":535},{"body_character":"uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {int8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }","children":[{"body_character":"///printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n","children":[],"id":"59","children_ids":[],"type":"comment","name":null,"body":"//printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n","line_start":96,"line_end":96,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"    ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":96,"start_statement_line_end":96,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":95,"end_statement_line_end":96,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":3232,"start_statement_char_start":3232,"start_statement_char_end":3234,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":3319,"end_statement_char_start":3318,"end_statement_char_end":3319,"end_statement_char_in_start":86,"end_statement_char_in_end":87},{"body_character":"///       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n","children":[],"id":"60","children_ids":[],"type":"comment","name":null,"body":"//       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n","line_start":97,"line_end":97,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"       ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":97,"start_statement_line_end":97,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":96,"end_statement_line_end":97,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":3323,"start_statement_char_start":3323,"start_statement_char_end":3325,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":3414,"end_statement_char_start":3413,"end_statement_char_end":3414,"end_statement_char_in_start":90,"end_statement_char_in_end":91}],"id":"58","children_ids":["59","60"],"type":"method","name":"*allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly)","body":"uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }","line_start":92,"line_end":100,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {","start_statement_line_start":92,"start_statement_line_end":94,"start_statement_line_in_start":1,"start_statement_line_in_end":3,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":100,"end_statement_line_end":100,"end_statement_line_in_start":9,"end_statement_line_in_end":9,"char_start":2914,"start_statement_char_start":2914,"start_statement_char_end":3111,"start_statement_char_in_start":0,"start_statement_char_in_end":197,"char_end":3496,"end_statement_char_start":3495,"end_statement_char_end":3496,"end_statement_char_in_start":581,"end_statement_char_in_end":582},{"body_character":" *sections_;*sections_;","children":[],"id":"61","children_ids":[],"type":"attribute","name":" *sections_","body":" *sections_","line_start":101,"line_end":101,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":" *sections_;","end_statement":"","start_statement_regexp":"/([a-zA-Z0-9_\\.,\\*:\\(\\) \\t]+)\\s*;/","start_statement_matched":" *sections_;","start_statement_line_start":101,"start_statement_line_end":101,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":101,"end_statement_line_end":101,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":3539,"start_statement_char_start":3539,"start_statement_char_end":3551,"start_statement_char_in_start":0,"start_statement_char_in_end":12,"char_end":3550,"end_statement_char_start":3550,"end_statement_char_end":3550,"end_statement_char_in_start":11,"end_statement_char_in_end":11}],"id":"52","children_ids":["53","54","55","58","61"],"type":"class","name":"MyMemoryManager","body":"class MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n}","line_start":75,"line_end":102,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"class MyMemoryManager : public SectionMemoryManager {","end_statement":"}","start_statement_regexp":"/class\\s+([A-Za-z0-9_]+)[A-Za-z0-9_\\\\\\s:]*{/","start_statement_matched":"class MyMemoryManager : public SectionMemoryManager {","start_statement_line_start":75,"start_statement_line_end":75,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":102,"end_statement_line_end":102,"end_statement_line_in_start":28,"end_statement_line_in_end":28,"char_start":2164,"start_statement_char_start":2164,"start_statement_char_end":2217,"start_statement_char_in_start":0,"start_statement_char_in_end":53,"char_end":3553,"end_statement_char_start":3552,"end_statement_char_end":3553,"end_statement_char_in_start":1388,"end_statement_char_in_end":1389},{"body_character":"BPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {PFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}","children":[{"body_character":"/** call empty function to force linking of MCJIT *","children":[],"id":"63","children_ids":[],"type":"comment","name":null,"body":"/* call empty function to force linking of MCJIT */","line_start":112,"line_end":112,"line_preserve_start_whitespaces":"   ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":112,"start_statement_line_end":112,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":112,"end_statement_line_end":112,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":3851,"start_statement_char_start":3851,"start_statement_char_end":3853,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":3902,"end_statement_char_start":3900,"end_statement_char_end":3902,"end_statement_char_in_start":49,"end_statement_char_in_end":51}],"id":"62","children_ids":["63"],"type":"method","name":"BPFModule::BPFModule(unsigned flags)","body":"BPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}","line_start":104,"line_end":113,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"BPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {","start_statement_line_start":104,"start_statement_line_end":105,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":113,"end_statement_line_end":113,"end_statement_line_in_start":10,"end_statement_line_in_end":10,"char_start":3556,"start_statement_char_start":3556,"start_statement_char_end":3637,"start_statement_char_in_start":0,"start_statement_char_in_end":81,"char_end":3904,"end_statement_char_start":3903,"end_statement_char_end":3904,"end_statement_char_in_start":347,"end_statement_char_in_end":348},{"body_character":"BPFModule::~BPFModule() {PFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}","children":[{"body_character":"{\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }","children":[{"body_character":"{\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }","children":[],"id":"66","children_ids":[],"type":"statement","name":null,"body":"{\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }","line_start":120,"line_end":123,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":120,"start_statement_line_end":120,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":123,"end_statement_line_end":123,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":4038,"start_statement_char_start":4038,"start_statement_char_end":4039,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":4129,"end_statement_char_start":4128,"end_statement_char_end":4129,"end_statement_char_in_start":90,"end_statement_char_in_end":91}],"id":"65","children_ids":["66"],"type":"statement","name":null,"body":"{\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }","line_start":119,"line_end":124,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":119,"start_statement_line_end":119,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":124,"end_statement_line_end":124,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":4004,"start_statement_char_start":4004,"start_statement_char_end":4005,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":4133,"end_statement_char_start":4132,"end_statement_char_end":4133,"end_statement_char_in_start":128,"end_statement_char_in_end":129}],"id":"64","children_ids":["65"],"type":"method","name":"BPFModule::~BPFModule()","body":"BPFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}","line_start":115,"line_end":125,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"BPFModule::~BPFModule() {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::~BPFModule() {","start_statement_line_start":115,"start_statement_line_end":115,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":125,"end_statement_line_end":125,"end_statement_line_in_start":11,"end_statement_line_in_end":11,"char_start":3906,"start_statement_char_start":3906,"start_statement_char_end":3931,"start_statement_char_in_start":0,"start_statement_char_in_end":25,"char_end":4135,"end_statement_char_start":4134,"end_statement_char_end":4135,"end_statement_char_in_start":228,"end_statement_char_in_end":229},{"body_character":"static void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {tatic void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf);\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf, mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}","children":[{"body_character":"{B.getInt64(0), B.getInt64(0)}","children":[],"id":"68","children_ids":[],"type":"statement","name":null,"body":"{B.getInt64(0), B.getInt64(0)}","line_start":129,"line_end":129,"line_preserve_start_whitespaces":"     ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":129,"start_statement_line_end":129,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":129,"end_statement_line_end":129,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":4371,"start_statement_char_start":4371,"start_statement_char_end":4372,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":4401,"end_statement_char_start":4400,"end_statement_char_end":4401,"end_statement_char_in_start":29,"end_statement_char_in_end":30},{"body_character":"{\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf, mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }","children":[{"body_character":"{B.getInt64Ty(), B.getInt8PtrTy()}","children":[],"id":"70","children_ids":[],"type":"statement","name":null,"body":"{B.getInt64Ty(), B.getInt8PtrTy()}","line_start":133,"line_end":133,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":133,"start_statement_line_end":133,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":133,"end_statement_line_end":133,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":4576,"start_statement_char_start":4576,"start_statement_char_end":4577,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":4610,"end_statement_char_start":4609,"end_statement_char_end":4610,"end_statement_char_in_start":33,"end_statement_char_in_end":34},{"body_character":"/**isvarArg=*","children":[],"id":"71","children_ids":[],"type":"comment","name":null,"body":"/*isvarArg=*/","line_start":134,"line_end":134,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":134,"start_statement_line_end":134,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":134,"end_statement_line_end":134,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":4700,"start_statement_char_start":4700,"start_statement_char_end":4702,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":4713,"end_statement_char_start":4711,"end_statement_char_end":4713,"end_statement_char_in_start":11,"end_statement_char_in_end":13}],"id":"69","children_ids":["70","71"],"type":"statement","name":null,"body":"{\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf\", mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }","line_start":132,"line_end":138,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":132,"start_statement_line_end":132,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":138,"end_statement_line_end":138,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":4539,"start_statement_char_start":4539,"start_statement_char_end":4540,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":4917,"end_statement_char_start":4916,"end_statement_char_end":4917,"end_statement_char_in_start":377,"end_statement_char_in_end":378}],"id":"67","children_ids":["68","69"],"type":"method","name":"debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args)","body":"static void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf\");\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf\", mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}","line_start":127,"line_end":140,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"static void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"static void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {","start_statement_line_start":127,"start_statement_line_end":127,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":140,"end_statement_line_end":140,"end_statement_line_in_start":14,"end_statement_line_in_end":14,"char_start":4137,"start_statement_char_start":4137,"start_statement_char_end":4233,"start_statement_char_in_start":0,"start_statement_char_in_end":96,"char_end":4953,"end_statement_char_start":4952,"end_statement_char_end":4953,"end_statement_char_in_start":815,"end_statement_char_in_end":816},{"body_character":"/// recursive helper to capture the arguments\n","children":[],"id":"72","children_ids":[],"type":"comment","name":null,"body":"// recursive helper to capture the arguments\n","line_start":142,"line_end":142,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"        ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":142,"start_statement_line_end":142,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":141,"end_statement_line_end":142,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":4955,"start_statement_char_start":4955,"start_statement_char_end":4957,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":5000,"end_statement_char_start":4999,"end_statement_char_end":5000,"end_statement_char_in_start":44,"end_statement_char_in_end":45},{"body_character":"parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {arse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ ;\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"};\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ ;\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"];\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x;\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh;\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h;\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%;\n    else\n      *fmt += \"%l;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}","children":[{"body_character":"{\n    *fmt += \"{ ;\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"};\n  }","children":[{"body_character":"{\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" ;\n    }","children":[],"id":"75","children_ids":[],"type":"statement","name":null,"body":"{\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }","line_start":148,"line_end":151,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":148,"start_statement_line_end":148,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":151,"end_statement_line_end":151,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":5271,"start_statement_char_start":5271,"start_statement_char_end":5272,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":5384,"end_statement_char_start":5383,"end_statement_char_end":5384,"end_statement_char_in_start":112,"end_statement_char_in_end":113}],"id":"74","children_ids":["75"],"type":"statement","name":null,"body":"{\n    *fmt += \"{ \";\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"}\";\n  }","line_start":145,"line_end":153,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"       ","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":145,"start_statement_line_end":145,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":153,"end_statement_line_end":153,"end_statement_line_in_start":9,"end_statement_line_in_end":9,"char_start":5191,"start_statement_char_start":5191,"start_statement_char_end":5192,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":5405,"end_statement_char_start":5404,"end_statement_char_end":5405,"end_statement_char_in_start":213,"end_statement_char_in_end":214},{"body_character":"{\n    *fmt += \"[ ;\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" ;\n    }\n    *fmt += \"];\n  }","children":[{"body_character":"{\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" ;\n    }","children":[],"id":"77","children_ids":[],"type":"statement","name":null,"body":"{\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }","line_start":155,"line_end":158,"line_preserve_start_whitespaces":"             ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":155,"start_statement_line_end":155,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":158,"end_statement_line_end":158,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":5532,"start_statement_char_start":5532,"start_statement_char_end":5533,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":5656,"end_statement_char_start":5655,"end_statement_char_end":5656,"end_statement_char_in_start":123,"end_statement_char_in_end":124}],"id":"76","children_ids":["77"],"type":"statement","name":null,"body":"{\n    *fmt += \"[ \";\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"]\";\n  }","line_start":153,"line_end":160,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"    ","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":153,"start_statement_line_end":153,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":160,"end_statement_line_end":160,"end_statement_line_in_start":8,"end_statement_line_in_end":8,"char_start":5458,"start_statement_char_start":5458,"start_statement_char_end":5459,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":5677,"end_statement_char_start":5676,"end_statement_char_end":5677,"end_statement_char_in_start":218,"end_statement_char_in_end":219},{"body_character":"{\n    *fmt += \"0xl;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n  }","children":[],"id":"78","children_ids":[],"type":"statement","name":null,"body":"{\n    *fmt += \"0xl\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n  }","line_start":160,"line_end":166,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"       ","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":160,"start_statement_line_end":160,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":166,"end_statement_line_end":166,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":5711,"start_statement_char_start":5711,"start_statement_char_end":5712,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":5801,"end_statement_char_start":5800,"end_statement_char_end":5801,"end_statement_char_in_start":89,"end_statement_char_in_end":90},{"body_character":"{\n    if (is_writer)\n      *fmt += \"0x;\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh;\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h;\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%;\n    else\n      *fmt += \"%l;\n    if (is_writer)\n      *fmt += \"x;\n    else\n      *fmt += \"i;\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }","children":[],"id":"79","children_ids":[],"type":"statement","name":null,"body":"{\n    if (is_writer)\n      *fmt += \"0x\";\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh\";\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h\";\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%\";\n    else\n      *fmt += \"%l\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }","line_start":166,"line_end":182,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":166,"start_statement_line_end":166,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":182,"end_statement_line_end":182,"end_statement_line_in_start":17,"end_statement_line_in_end":17,"char_start":5858,"start_statement_char_start":5858,"start_statement_char_end":5859,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":6223,"end_statement_char_start":6222,"end_statement_char_end":6223,"end_statement_char_in_start":364,"end_statement_char_in_end":365}],"id":"73","children_ids":["74","76","78","79"],"type":"method","name":"parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer)","body":"parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ \";\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"}\";\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ \";\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"]\";\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x\";\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh\";\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h\";\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%\";\n    else\n      *fmt += \"%l\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}","line_start":143,"line_end":183,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {","start_statement_line_start":143,"start_statement_line_end":144,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":183,"end_statement_line_end":183,"end_statement_line_in_start":41,"end_statement_line_in_end":41,"char_start":5012,"start_statement_char_start":5012,"start_statement_char_end":5139,"start_statement_char_in_start":0,"start_statement_char_in_end":127,"char_end":6225,"end_statement_char_start":6224,"end_statement_char_end":6225,"end_statement_char_in_start":1212,"end_statement_char_in_end":1213},{"body_character":"Function * BPFModule::make_reader(Module *mod, Type *type) {unction * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in);\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out);\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry, fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit, fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n, vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf);\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf, mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then, fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}","children":[{"body_character":"/// int read(const char *in, Type *out) {\n","children":[],"id":"81","children_ids":[],"type":"comment","name":null,"body":"// int read(const char *in, Type *out) {\n","line_start":190,"line_end":190,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":190,"start_statement_line_end":190,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":189,"end_statement_line_end":190,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":6384,"start_statement_char_start":6384,"start_statement_char_end":6386,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6425,"end_statement_char_start":6424,"end_statement_char_end":6425,"end_statement_char_in_start":40,"end_statement_char_in_end":41},{"body_character":"///   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n","children":[],"id":"82","children_ids":[],"type":"comment","name":null,"body":"//   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n","line_start":191,"line_end":191,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":191,"start_statement_line_end":191,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":190,"end_statement_line_end":191,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":6427,"start_statement_char_start":6427,"start_statement_char_end":6429,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6485,"end_statement_char_start":6484,"end_statement_char_end":6485,"end_statement_char_in_start":57,"end_statement_char_in_end":58},{"body_character":"///   if (n != num_fields) return -1;\n","children":[],"id":"83","children_ids":[],"type":"comment","name":null,"body":"//   if (n != num_fields) return -1;\n","line_start":192,"line_end":192,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":192,"start_statement_line_end":192,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":191,"end_statement_line_end":192,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":6487,"start_statement_char_start":6487,"start_statement_char_end":6489,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6524,"end_statement_char_start":6523,"end_statement_char_end":6524,"end_statement_char_in_start":36,"end_statement_char_in_end":37},{"body_character":"///   return 0;\n","children":[],"id":"84","children_ids":[],"type":"comment","name":null,"body":"//   return 0;\n","line_start":193,"line_end":193,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":193,"start_statement_line_end":193,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":192,"end_statement_line_end":193,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":6526,"start_statement_char_start":6526,"start_statement_char_end":6528,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6541,"end_statement_char_start":6540,"end_statement_char_end":6541,"end_statement_char_in_start":14,"end_statement_char_in_end":15},{"body_character":"/// }\n","children":[],"id":"85","children_ids":[],"type":"comment","name":null,"body":"// }\n","line_start":194,"line_end":194,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":194,"start_statement_line_end":194,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":193,"end_statement_line_end":194,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":6543,"start_statement_char_start":6543,"start_statement_char_end":6545,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6548,"end_statement_char_start":6547,"end_statement_char_end":6548,"end_statement_char_in_start":4,"end_statement_char_in_end":5},{"body_character":"{B.getInt8PtrTy(), PointerType::getUnqual(type)}","children":[],"id":"86","children_ids":[],"type":"statement","name":null,"body":"{B.getInt8PtrTy(), PointerType::getUnqual(type)}","line_start":198,"line_end":198,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":198,"start_statement_line_end":198,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":198,"end_statement_line_end":198,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":6599,"start_statement_char_start":6599,"start_statement_char_end":6600,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":6647,"end_statement_char_start":6646,"end_statement_char_end":6647,"end_statement_char_in_start":47,"end_statement_char_in_end":48},{"body_character":"/**isVarArg=*","children":[],"id":"87","children_ids":[],"type":"comment","name":null,"body":"/*isVarArg=*/","line_start":199,"line_end":199,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":199,"start_statement_line_end":199,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":199,"end_statement_line_end":199,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":6719,"start_statement_char_start":6719,"start_statement_char_end":6721,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":6732,"end_statement_char_start":6730,"end_statement_char_end":6732,"end_statement_char_in_start":11,"end_statement_char_in_end":13},{"body_character":"{arg_in, nullptr}","children":[],"id":"88","children_ids":[],"type":"statement","name":null,"body":"{arg_in, nullptr}","line_start":214,"line_end":214,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":214,"start_statement_line_end":214,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":214,"end_statement_line_end":214,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":7261,"start_statement_char_start":7261,"start_statement_char_end":7262,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":7278,"end_statement_char_start":7277,"end_statement_char_end":7278,"end_statement_char_in_start":16,"end_statement_char_in_end":17},{"body_character":"{B.getInt64(0), B.getInt64(0)}","children":[],"id":"89","children_ids":[],"type":"statement","name":null,"body":"{B.getInt64(0), B.getInt64(0)}","line_start":220,"line_end":220,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":220,"start_statement_line_end":220,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":220,"end_statement_line_end":220,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":7470,"start_statement_char_start":7470,"start_statement_char_end":7471,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":7500,"end_statement_char_start":7499,"end_statement_char_end":7500,"end_statement_char_in_start":29,"end_statement_char_in_end":30},{"body_character":"{arg_in, arg_out}","children":[],"id":"90","children_ids":[],"type":"statement","name":null,"body":"{arg_in, arg_out}","line_start":223,"line_end":223,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":223,"start_statement_line_end":223,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":223,"end_statement_line_end":223,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":7566,"start_statement_char_start":7566,"start_statement_char_end":7567,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":7583,"end_statement_char_start":7582,"end_statement_char_end":7583,"end_statement_char_in_start":16,"end_statement_char_in_end":17},{"body_character":"{B.getInt8PtrTy(), B.getInt8PtrTy()}","children":[],"id":"91","children_ids":[],"type":"statement","name":null,"body":"{B.getInt8PtrTy(), B.getInt8PtrTy()}","line_start":225,"line_end":225,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":225,"start_statement_line_end":225,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":225,"end_statement_line_end":225,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":7620,"start_statement_char_start":7620,"start_statement_char_end":7621,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":7656,"end_statement_char_start":7655,"end_statement_char_end":7656,"end_statement_char_in_start":35,"end_statement_char_in_end":36},{"body_character":"/**isVarArg=*","children":[],"id":"92","children_ids":[],"type":"comment","name":null,"body":"/*isVarArg=*/","line_start":226,"line_end":226,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":226,"start_statement_line_end":226,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":226,"end_statement_line_end":226,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":7742,"start_statement_char_start":7742,"start_statement_char_end":7744,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":7755,"end_statement_char_start":7753,"end_statement_char_end":7755,"end_statement_char_in_start":11,"end_statement_char_in_end":13}],"id":"80","children_ids":["81","82","83","84","85","86","87","88","89","90","91","92"],"type":"method","name":"BPFModule::make_reader(Module *mod, Type *type)","body":"Function * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader\" + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n\", vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf\");\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf\", mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then\", fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}","line_start":185,"line_end":249,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"Function * BPFModule::make_reader(Module *mod, Type *type) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"Function * BPFModule::make_reader(Module *mod, Type *type) {","start_statement_line_start":185,"start_statement_line_end":185,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":249,"end_statement_line_end":249,"end_statement_line_in_start":65,"end_statement_line_in_end":65,"char_start":6227,"start_statement_char_start":6227,"start_statement_char_end":6287,"start_statement_char_in_start":0,"start_statement_char_in_end":60,"char_end":8447,"end_statement_char_start":8446,"end_statement_char_end":8447,"end_statement_char_in_start":2219,"end_statement_char_in_end":2220},{"body_character":"Function * BPFModule::make_writer(Module *mod, Type *type) {unction * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out);\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len);\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in);\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry, fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt);\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n, vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf);\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf, mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}","children":[{"body_character":"/// int write(int len, char *out, Type *in) {\n","children":[],"id":"94","children_ids":[],"type":"comment","name":null,"body":"// int write(int len, char *out, Type *in) {\n","line_start":256,"line_end":256,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":256,"start_statement_line_end":256,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":255,"end_statement_line_end":256,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":8606,"start_statement_char_start":8606,"start_statement_char_end":8608,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":8651,"end_statement_char_start":8650,"end_statement_char_end":8651,"end_statement_char_in_start":44,"end_statement_char_in_end":45},{"body_character":"///   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n","children":[],"id":"95","children_ids":[],"type":"comment","name":null,"body":"//   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n","line_start":257,"line_end":257,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":257,"start_statement_line_end":257,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":256,"end_statement_line_end":257,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":8653,"start_statement_char_start":8653,"start_statement_char_end":8655,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":8717,"end_statement_char_start":8716,"end_statement_char_end":8717,"end_statement_char_in_start":63,"end_statement_char_in_end":64},{"body_character":"/// }\n","children":[],"id":"96","children_ids":[],"type":"comment","name":null,"body":"// }\n","line_start":258,"line_end":258,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":258,"start_statement_line_end":258,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":257,"end_statement_line_end":258,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":8719,"start_statement_char_start":8719,"start_statement_char_end":8721,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":8724,"end_statement_char_start":8723,"end_statement_char_end":8724,"end_statement_char_in_start":4,"end_statement_char_in_end":5},{"body_character":"{B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)}","children":[],"id":"97","children_ids":[],"type":"statement","name":null,"body":"{B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)}","line_start":262,"line_end":262,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":262,"start_statement_line_end":262,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":262,"end_statement_line_end":262,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":8775,"start_statement_char_start":8775,"start_statement_char_end":8776,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":8839,"end_statement_char_start":8838,"end_statement_char_end":8839,"end_statement_char_in_start":63,"end_statement_char_in_end":64},{"body_character":"/**isVarArg=*","children":[],"id":"98","children_ids":[],"type":"comment","name":null,"body":"/*isVarArg=*/","line_start":263,"line_end":263,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":263,"start_statement_line_end":263,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":263,"end_statement_line_end":263,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":8911,"start_statement_char_start":8911,"start_statement_char_end":8913,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":8924,"end_statement_char_start":8922,"end_statement_char_end":8924,"end_statement_char_in_start":11,"end_statement_char_in_end":13},{"body_character":"{arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr}","children":[],"id":"99","children_ids":[],"type":"statement","name":null,"body":"{arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr}","line_start":280,"line_end":280,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":280,"start_statement_line_end":280,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":280,"end_statement_line_end":280,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":9458,"start_statement_char_start":9458,"start_statement_char_end":9459,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":9515,"end_statement_char_start":9514,"end_statement_char_end":9515,"end_statement_char_in_start":56,"end_statement_char_in_end":57},{"body_character":"{B.getInt64(0), B.getInt64(0)}","children":[],"id":"100","children_ids":[],"type":"statement","name":null,"body":"{B.getInt64(0), B.getInt64(0)}","line_start":286,"line_end":286,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":286,"start_statement_line_end":286,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":286,"end_statement_line_end":286,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":9705,"start_statement_char_start":9705,"start_statement_char_end":9706,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":9735,"end_statement_char_start":9734,"end_statement_char_end":9735,"end_statement_char_in_start":29,"end_statement_char_in_end":30},{"body_character":"{arg_len, arg_out, arg_in}","children":[],"id":"101","children_ids":[],"type":"statement","name":null,"body":"{arg_len, arg_out, arg_in}","line_start":289,"line_end":289,"line_preserve_start_whitespaces":"          ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":289,"start_statement_line_end":289,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":289,"end_statement_line_end":289,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":9804,"start_statement_char_start":9804,"start_statement_char_end":9805,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":9830,"end_statement_char_start":9829,"end_statement_char_end":9830,"end_statement_char_in_start":25,"end_statement_char_in_end":26},{"body_character":"{B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()}","children":[],"id":"102","children_ids":[],"type":"statement","name":null,"body":"{B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()}","line_start":291,"line_end":291,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":291,"start_statement_line_end":291,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":291,"end_statement_line_end":291,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":9869,"start_statement_char_start":9869,"start_statement_char_end":9870,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":9921,"end_statement_char_start":9920,"end_statement_char_end":9921,"end_statement_char_in_start":51,"end_statement_char_in_end":52},{"body_character":"/**isVarArg=*","children":[],"id":"103","children_ids":[],"type":"comment","name":null,"body":"/*isVarArg=*/","line_start":292,"line_end":292,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":292,"start_statement_line_end":292,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":292,"end_statement_line_end":292,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":10011,"start_statement_char_start":10011,"start_statement_char_end":10013,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":10024,"end_statement_char_start":10022,"end_statement_char_end":10024,"end_statement_char_in_start":11,"end_statement_char_in_end":13}],"id":"93","children_ids":["94","95","96","97","98","99","100","101","102","103"],"type":"method","name":"BPFModule::make_writer(Module *mod, Type *type)","body":"Function * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer\" + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len\");\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n\", vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf\");\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf\", mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}","line_start":251,"line_end":306,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"Function * BPFModule::make_writer(Module *mod, Type *type) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"Function * BPFModule::make_writer(Module *mod, Type *type) {","start_statement_line_start":251,"start_statement_line_end":251,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":306,"end_statement_line_end":306,"end_statement_line_in_start":56,"end_statement_line_in_end":56,"char_start":8449,"start_statement_char_start":8449,"start_statement_char_end":8509,"start_statement_char_in_start":0,"start_statement_char_in_end":60,"char_end":10442,"end_statement_char_start":10441,"end_statement_char_end":10442,"end_statement_char_in_start":1992,"end_statement_char_in_end":1993},{"body_character":"unique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {nique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n, err.c_str());\n  return engine;\n}","children":[],"id":"104","children_ids":[],"type":"method","name":"BPFModule::finalize_rw(unique_ptr<Module> m)","body":"unique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n  return engine;\n}","line_start":308,"line_end":321,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"unique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"unique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {","start_statement_line_start":308,"start_statement_line_end":308,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":321,"end_statement_line_end":321,"end_statement_line_in_start":14,"end_statement_line_in_end":14,"char_start":10444,"start_statement_char_start":10444,"start_statement_char_end":10518,"start_statement_char_in_start":0,"start_statement_char_in_end":74,"char_end":10860,"end_statement_char_start":10859,"end_statement_char_end":10860,"end_statement_char_in_start":415,"end_statement_char_in_end":416},{"body_character":"/// load an entire c file as a module\n","children":[],"id":"105","children_ids":[],"type":"comment","name":null,"body":"// load an entire c file as a module\n","line_start":323,"line_end":323,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"           ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":323,"start_statement_line_end":323,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":322,"end_statement_line_end":323,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":10862,"start_statement_char_start":10862,"start_statement_char_end":10864,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":10899,"end_statement_char_start":10898,"end_statement_char_end":10899,"end_statement_char_in_start":36,"end_statement_char_in_end":37},{"body_character":"BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {PFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}","children":[],"id":"106","children_ids":[],"type":"method","name":"BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags)","body":"BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}","line_start":324,"line_end":329,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {","start_statement_line_start":324,"start_statement_line_end":324,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":329,"end_statement_line_end":329,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":10903,"start_statement_char_start":10903,"start_statement_char_end":10997,"start_statement_char_in_start":0,"start_statement_char_in_end":94,"char_end":11165,"end_statement_char_start":11164,"end_statement_char_end":11165,"end_statement_char_in_start":261,"end_statement_char_in_end":262},{"body_character":"/// NOTE: this is a duplicate of the above, but planning to deprecate if we\n","children":[],"id":"107","children_ids":[],"type":"comment","name":null,"body":"// NOTE: this is a duplicate of the above, but planning to deprecate if we\n","line_start":331,"line_end":331,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":331,"start_statement_line_end":331,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":330,"end_statement_line_end":331,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":11167,"start_statement_char_start":11167,"start_statement_char_end":11169,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":11242,"end_statement_char_start":11241,"end_statement_char_end":11242,"end_statement_char_in_start":74,"end_statement_char_in_end":75},{"body_character":"/// settle on clang as the frontend\n","children":[],"id":"108","children_ids":[],"type":"comment","name":null,"body":"// settle on clang as the frontend\n","line_start":332,"line_end":332,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":332,"start_statement_line_end":332,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":331,"end_statement_line_end":332,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":11242,"start_statement_char_start":11242,"start_statement_char_end":11244,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":11277,"end_statement_char_start":11276,"end_statement_char_end":11277,"end_statement_char_in_start":34,"end_statement_char_in_end":35},{"body_character":"/// Load in a pre-built list of functions into the initial Module object, then\n","children":[],"id":"109","children_ids":[],"type":"comment","name":null,"body":"// Load in a pre-built list of functions into the initial Module object, then\n","line_start":334,"line_end":334,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":334,"start_statement_line_end":334,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":333,"end_statement_line_end":334,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":11278,"start_statement_char_start":11278,"start_statement_char_end":11280,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":11356,"end_statement_char_start":11355,"end_statement_char_end":11356,"end_statement_char_in_start":77,"end_statement_char_in_end":78},{"body_character":"/// build an ExecutionEngine.\n","children":[],"id":"110","children_ids":[],"type":"comment","name":null,"body":"// build an ExecutionEngine.\n","line_start":335,"line_end":335,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"    ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":335,"start_statement_line_end":335,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":334,"end_statement_line_end":335,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":11356,"start_statement_char_start":11356,"start_statement_char_end":11358,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":11385,"end_statement_char_start":11384,"end_statement_char_end":11385,"end_statement_char_in_start":28,"end_statement_char_in_end":29},{"body_character":"int BPFModule::load_includes(const string &text) {nt BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}","children":[],"id":"111","children_ids":[],"type":"method","name":"BPFModule::load_includes(const string &text)","body":"int BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}","line_start":336,"line_end":341,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::load_includes(const string &text) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::load_includes(const string &text) {","start_statement_line_start":336,"start_statement_line_end":336,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":341,"end_statement_line_end":341,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":11385,"start_statement_char_start":11385,"start_statement_char_end":11435,"start_statement_char_in_start":0,"start_statement_char_in_end":50,"char_end":11593,"end_statement_char_start":11592,"end_statement_char_end":11593,"end_statement_char_in_start":207,"end_statement_char_in_end":208},{"body_character":"int BPFModule::annotate() {nt BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf, *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for  << *key_type << \"\\n;\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for  << *leaf_type << \"\\n;\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for  << *key_type << \"\\n;\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for  << *leaf_type << \"\\n;\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}","children":[{"body_character":"/// separate module to hold the reader functions\n","children":[],"id":"113","children_ids":[],"type":"comment","name":null,"body":"// separate module to hold the reader functions\n","line_start":347,"line_end":347,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"      ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":347,"start_statement_line_end":347,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":346,"end_statement_line_end":347,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":11763,"start_statement_char_start":11763,"start_statement_char_end":11765,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":11811,"end_statement_char_start":11810,"end_statement_char_end":11811,"end_statement_char_in_start":47,"end_statement_char_in_end":48},{"body_character":"{\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for  << *key_type << \"\\n;\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for  << *leaf_type << \"\\n;\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for  << *key_type << \"\\n;\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for  << *leaf_type << \"\\n;\n      }\n    }\n  }","children":[{"body_character":"{\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for  << *key_type << \"\\n;\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for  << *leaf_type << \"\\n;\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for  << *key_type << \"\\n;\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for  << *leaf_type << \"\\n;\n      }\n    }","children":[{"body_character":"{\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for  << *key_type << \"\\n;\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for  << *leaf_type << \"\\n;\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for  << *key_type << \"\\n;\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for  << *leaf_type << \"\\n;\n      }","children":[],"id":"116","children_ids":[],"type":"statement","name":null,"body":"{\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }","line_start":356,"line_end":372,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":356,"start_statement_line_end":356,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":372,"end_statement_line_end":372,"end_statement_line_in_start":17,"end_statement_line_in_end":17,"char_start":12169,"start_statement_char_start":12169,"start_statement_char_end":12170,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":12975,"end_statement_char_start":12974,"end_statement_char_end":12975,"end_statement_char_in_start":805,"end_statement_char_in_end":806}],"id":"115","children_ids":["116"],"type":"statement","name":null,"body":"{\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }","line_start":355,"line_end":373,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":355,"start_statement_line_end":355,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":373,"end_statement_line_end":373,"end_statement_line_in_start":19,"end_statement_line_in_end":19,"char_start":12096,"start_statement_char_start":12096,"start_statement_char_end":12097,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":12981,"end_statement_char_start":12980,"end_statement_char_end":12981,"end_statement_char_in_start":884,"end_statement_char_in_end":885}],"id":"114","children_ids":["115"],"type":"statement","name":null,"body":"{\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }\n  }","line_start":351,"line_end":374,"line_preserve_start_whitespaces":"       ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":351,"start_statement_line_end":351,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":374,"end_statement_line_end":374,"end_statement_line_in_start":24,"end_statement_line_in_end":24,"char_start":11909,"start_statement_char_start":11909,"start_statement_char_end":11910,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":12985,"end_statement_char_start":12984,"end_statement_char_end":12985,"end_statement_char_in_start":1075,"end_statement_char_in_end":1076}],"id":"112","children_ids":["113","114"],"type":"method","name":"BPFModule::annotate()","body":"int BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf\", *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}","line_start":343,"line_end":381,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::annotate() {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::annotate() {","start_statement_line_start":343,"start_statement_line_end":343,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":381,"end_statement_line_end":381,"end_statement_line_in_start":39,"end_statement_line_in_end":39,"char_start":11595,"start_statement_char_start":11595,"start_statement_char_end":11622,"start_statement_char_in_start":0,"start_statement_char_in_end":27,"char_end":13090,"end_statement_char_start":13089,"end_statement_char_end":13090,"end_statement_char_in_start":1494,"end_statement_char_in_end":1495},{"body_character":"void BPFModule::dump_ir(Module &mod) {oid BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}","children":[],"id":"117","children_ids":[],"type":"method","name":"BPFModule::dump_ir(Module &mod)","body":"void BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}","line_start":383,"line_end":387,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"void BPFModule::dump_ir(Module &mod) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"void BPFModule::dump_ir(Module &mod) {","start_statement_line_start":383,"start_statement_line_end":383,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":387,"end_statement_line_end":387,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":13092,"start_statement_char_start":13092,"start_statement_char_end":13130,"start_statement_char_in_start":0,"start_statement_char_in_end":38,"char_end":13214,"end_statement_char_start":13213,"end_statement_char_end":13214,"end_statement_char_in_start":121,"end_statement_char_in_end":122},{"body_character":"int BPFModule::run_pass_manager(Module &mod) {nt BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}","children":[{"body_character":"{\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }","children":[],"id":"119","children_ids":[],"type":"statement","name":null,"body":"{\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }","line_start":390,"line_end":394,"line_preserve_start_whitespaces":"     ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":390,"start_statement_line_end":390,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":394,"end_statement_line_end":394,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":13297,"start_statement_char_start":13297,"start_statement_char_end":13298,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":13357,"end_statement_char_start":13356,"end_statement_char_end":13357,"end_statement_char_in_start":59,"end_statement_char_in_end":60},{"body_character":"/**\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   *","children":[],"id":"120","children_ids":[],"type":"comment","name":null,"body":"/*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */","line_start":400,"line_end":406,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"/*","end_statement":"*/","start_statement_regexp":"/\\/\\*/","start_statement_matched":"/*","start_statement_line_start":400,"start_statement_line_end":400,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\*\\//","end_statement_matched":"*/","end_statement_line_start":406,"end_statement_line_end":406,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":13473,"start_statement_char_start":13473,"start_statement_char_end":13475,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":13647,"end_statement_char_start":13645,"end_statement_char_end":13647,"end_statement_char_in_start":172,"end_statement_char_in_end":174}],"id":"118","children_ids":["119","120"],"type":"method","name":"BPFModule::run_pass_manager(Module &mod)","body":"int BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}","line_start":389,"line_end":413,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::run_pass_manager(Module &mod) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::run_pass_manager(Module &mod) {","start_statement_line_start":389,"start_statement_line_end":389,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":413,"end_statement_line_end":413,"end_statement_line_in_start":25,"end_statement_line_in_end":25,"char_start":13216,"start_statement_char_start":13216,"start_statement_char_end":13262,"start_statement_char_in_start":0,"start_statement_char_in_end":46,"char_end":13845,"end_statement_char_start":13844,"end_statement_char_end":13845,"end_statement_char_in_start":628,"end_statement_char_in_end":629},{"body_character":"int BPFModule::finalize() {nt BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128);\n  mod->setTargetTriple(\"bpf-pc-linux);\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf);\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n, err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n, err.c_str());\n    return -1;\n  }","children":[],"id":"122","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n    return -1;\n  }","line_start":428,"line_end":431,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":428,"start_statement_line_end":428,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":431,"end_statement_line_end":431,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":14299,"start_statement_char_start":14299,"start_statement_char_end":14300,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":14395,"end_statement_char_start":14394,"end_statement_char_end":14395,"end_statement_char_in_start":95,"end_statement_char_in_end":96},{"body_character":"/// give functions an id\n","children":[],"id":"123","children_ids":[],"type":"comment","name":null,"body":"// give functions an id\n","line_start":438,"line_end":438,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"      ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":438,"start_statement_line_end":438,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":437,"end_statement_line_end":438,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":14484,"start_statement_char_start":14484,"start_statement_char_end":14486,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":14508,"end_statement_char_start":14507,"end_statement_char_end":14508,"end_statement_char_in_start":23,"end_statement_char_in_end":24}],"id":"121","children_ids":["122","123"],"type":"method","name":"BPFModule::finalize()","body":"int BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128\");\n  mod->setTargetTriple(\"bpf-pc-linux\");\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf\");\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}","line_start":415,"line_end":444,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::finalize() {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::finalize() {","start_statement_line_start":415,"start_statement_line_end":415,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":444,"end_statement_line_end":444,"end_statement_line_in_start":30,"end_statement_line_in_end":30,"char_start":13847,"start_statement_char_start":13847,"start_statement_char_end":13874,"start_statement_char_in_start":0,"start_statement_char_in_end":27,"char_end":14681,"end_statement_char_start":14680,"end_statement_char_end":14681,"end_statement_char_in_start":833,"end_statement_char_in_end":834},{"body_character":"size_t BPFModule::num_functions() const {ize_t BPFModule::num_functions() const {\n  return function_names_.size();\n}","children":[],"id":"124","children_ids":[],"type":"method","name":"BPFModule::num_functions()","body":"size_t BPFModule::num_functions() const {\n  return function_names_.size();\n}","line_start":446,"line_end":448,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::num_functions() const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::num_functions() const {","start_statement_line_start":446,"start_statement_line_end":446,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":448,"end_statement_line_end":448,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":14683,"start_statement_char_start":14683,"start_statement_char_end":14724,"start_statement_char_in_start":0,"start_statement_char_in_end":41,"char_end":14759,"end_statement_char_start":14758,"end_statement_char_end":14759,"end_statement_char_in_start":75,"end_statement_char_in_end":76},{"body_character":"const char * BPFModule::function_name(size_t id) const {onst char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}","children":[],"id":"125","children_ids":[],"type":"method","name":"BPFModule::function_name(size_t id)","body":"const char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}","line_start":450,"line_end":454,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::function_name(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::function_name(size_t id) const {","start_statement_line_start":450,"start_statement_line_end":450,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":454,"end_statement_line_end":454,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":14761,"start_statement_char_start":14761,"start_statement_char_end":14817,"start_statement_char_in_start":0,"start_statement_char_in_end":56,"char_end":14932,"end_statement_char_start":14931,"end_statement_char_end":14932,"end_statement_char_in_start":170,"end_statement_char_in_end":171},{"body_character":"uint8_t * BPFModule::function_start(size_t id) const {int8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}","children":[],"id":"126","children_ids":[],"type":"method","name":"BPFModule::function_start(size_t id)","body":"uint8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}","line_start":456,"line_end":463,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"uint8_t * BPFModule::function_start(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"uint8_t * BPFModule::function_start(size_t id) const {","start_statement_line_start":456,"start_statement_line_end":456,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":463,"end_statement_line_end":463,"end_statement_line_in_start":8,"end_statement_line_in_end":8,"char_start":14934,"start_statement_char_start":14934,"start_statement_char_end":14988,"start_statement_char_in_start":0,"start_statement_char_in_end":54,"char_end":15188,"end_statement_char_start":15187,"end_statement_char_end":15188,"end_statement_char_in_start":253,"end_statement_char_in_end":254},{"body_character":"uint8_t * BPFModule::function_start(const string &name) const {int8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}","children":[],"id":"127","children_ids":[],"type":"method","name":"BPFModule::function_start(const string &name)","body":"uint8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}","line_start":465,"line_end":471,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"uint8_t * BPFModule::function_start(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"uint8_t * BPFModule::function_start(const string &name) const {","start_statement_line_start":465,"start_statement_line_end":465,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":471,"end_statement_line_end":471,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":15190,"start_statement_char_start":15190,"start_statement_char_end":15253,"start_statement_char_in_start":0,"start_statement_char_in_end":63,"char_end":15395,"end_statement_char_start":15394,"end_statement_char_end":15395,"end_statement_char_in_start":204,"end_statement_char_in_end":205},{"body_character":"size_t BPFModule::function_size(size_t id) const {ize_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}","children":[],"id":"128","children_ids":[],"type":"method","name":"BPFModule::function_size(size_t id)","body":"size_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}","line_start":473,"line_end":480,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::function_size(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::function_size(size_t id) const {","start_statement_line_start":473,"start_statement_line_end":473,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":480,"end_statement_line_end":480,"end_statement_line_in_start":8,"end_statement_line_in_end":8,"char_start":15397,"start_statement_char_start":15397,"start_statement_char_end":15447,"start_statement_char_in_start":0,"start_statement_char_in_end":50,"char_end":15635,"end_statement_char_start":15634,"end_statement_char_end":15635,"end_statement_char_in_start":237,"end_statement_char_in_end":238},{"body_character":"size_t BPFModule::function_size(const string &name) const {ize_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}","children":[],"id":"129","children_ids":[],"type":"method","name":"BPFModule::function_size(const string &name)","body":"size_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}","line_start":482,"line_end":488,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::function_size(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::function_size(const string &name) const {","start_statement_line_start":482,"start_statement_line_end":482,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":488,"end_statement_line_end":488,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":15637,"start_statement_char_start":15637,"start_statement_char_end":15696,"start_statement_char_in_start":0,"start_statement_char_in_end":59,"char_end":15832,"end_statement_char_start":15831,"end_statement_char_end":15832,"end_statement_char_in_start":194,"end_statement_char_in_end":195},{"body_character":"char * BPFModule::license() const {har * BPFModule::license() const {\n  auto section = sections_.find(\"license);\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}","children":[],"id":"130","children_ids":[],"type":"method","name":"BPFModule::license()","body":"char * BPFModule::license() const {\n  auto section = sections_.find(\"license\");\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}","line_start":490,"line_end":496,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"char * BPFModule::license() const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"char * BPFModule::license() const {","start_statement_line_start":490,"start_statement_line_end":490,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":496,"end_statement_line_end":496,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":15834,"start_statement_char_start":15834,"start_statement_char_end":15869,"start_statement_char_in_start":0,"start_statement_char_in_end":35,"char_end":16012,"end_statement_char_start":16011,"end_statement_char_end":16012,"end_statement_char_in_start":177,"end_statement_char_in_end":178},{"body_character":"unsigned BPFModule::kern_version() const {nsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version);\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}","children":[],"id":"131","children_ids":[],"type":"method","name":"BPFModule::kern_version()","body":"unsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version\");\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}","line_start":498,"line_end":504,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"unsigned BPFModule::kern_version() const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"unsigned BPFModule::kern_version() const {","start_statement_line_start":498,"start_statement_line_end":498,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":504,"end_statement_line_end":504,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":16014,"start_statement_char_start":16014,"start_statement_char_end":16056,"start_statement_char_in_start":0,"start_statement_char_in_end":42,"char_end":16198,"end_statement_char_start":16197,"end_statement_char_end":16198,"end_statement_char_in_start":183,"end_statement_char_in_end":184},{"body_character":"size_t BPFModule::num_tables() const {ize_t BPFModule::num_tables() const {\n  return tables_->size();\n}","children":[],"id":"132","children_ids":[],"type":"method","name":"BPFModule::num_tables()","body":"size_t BPFModule::num_tables() const {\n  return tables_->size();\n}","line_start":506,"line_end":508,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::num_tables() const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::num_tables() const {","start_statement_line_start":506,"start_statement_line_end":506,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":508,"end_statement_line_end":508,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":16200,"start_statement_char_start":16200,"start_statement_char_end":16238,"start_statement_char_in_start":0,"start_statement_char_in_end":38,"char_end":16266,"end_statement_char_start":16265,"end_statement_char_end":16266,"end_statement_char_in_start":65,"end_statement_char_in_end":66},{"body_character":"size_t BPFModule::table_id(const string &name) const {ize_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}","children":[],"id":"133","children_ids":[],"type":"method","name":"BPFModule::table_id(const string &name)","body":"size_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}","line_start":510,"line_end":514,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_id(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_id(const string &name) const {","start_statement_line_start":510,"start_statement_line_end":510,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":514,"end_statement_line_end":514,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":16268,"start_statement_char_start":16268,"start_statement_char_end":16322,"start_statement_char_in_start":0,"start_statement_char_in_end":54,"char_end":16428,"end_statement_char_start":16427,"end_statement_char_end":16428,"end_statement_char_in_start":159,"end_statement_char_in_end":160},{"body_character":"int BPFModule::table_fd(const string &name) const {nt BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}","children":[],"id":"134","children_ids":[],"type":"method","name":"BPFModule::table_fd(const string &name)","body":"int BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}","line_start":516,"line_end":518,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_fd(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_fd(const string &name) const {","start_statement_line_start":516,"start_statement_line_end":516,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":518,"end_statement_line_end":518,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":16430,"start_statement_char_start":16430,"start_statement_char_end":16481,"start_statement_char_in_start":0,"start_statement_char_in_end":51,"char_end":16518,"end_statement_char_start":16517,"end_statement_char_end":16518,"end_statement_char_in_start":87,"end_statement_char_in_end":88},{"body_character":"int BPFModule::table_fd(size_t id) const {nt BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}","children":[],"id":"135","children_ids":[],"type":"method","name":"BPFModule::table_fd(size_t id)","body":"int BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}","line_start":520,"line_end":523,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_fd(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_fd(size_t id) const {","start_statement_line_start":520,"start_statement_line_end":520,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":523,"end_statement_line_end":523,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":16520,"start_statement_char_start":16520,"start_statement_char_end":16562,"start_statement_char_in_start":0,"start_statement_char_in_end":42,"char_end":16632,"end_statement_char_start":16631,"end_statement_char_end":16632,"end_statement_char_in_start":111,"end_statement_char_in_end":112},{"body_character":"int BPFModule::table_type(const string &name) const {nt BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}","children":[],"id":"136","children_ids":[],"type":"method","name":"BPFModule::table_type(const string &name)","body":"int BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}","line_start":525,"line_end":527,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_type(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_type(const string &name) const {","start_statement_line_start":525,"start_statement_line_end":525,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":527,"end_statement_line_end":527,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":16634,"start_statement_char_start":16634,"start_statement_char_end":16687,"start_statement_char_in_start":0,"start_statement_char_in_end":53,"char_end":16726,"end_statement_char_start":16725,"end_statement_char_end":16726,"end_statement_char_in_start":91,"end_statement_char_in_end":92},{"body_character":"int BPFModule::table_type(size_t id) const {nt BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}","children":[],"id":"137","children_ids":[],"type":"method","name":"BPFModule::table_type(size_t id)","body":"int BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}","line_start":529,"line_end":532,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_type(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_type(size_t id) const {","start_statement_line_start":529,"start_statement_line_end":529,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":532,"end_statement_line_end":532,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":16728,"start_statement_char_start":16728,"start_statement_char_end":16772,"start_statement_char_in_start":0,"start_statement_char_in_end":44,"char_end":16844,"end_statement_char_start":16843,"end_statement_char_end":16844,"end_statement_char_in_start":115,"end_statement_char_in_end":116},{"body_character":"size_t BPFModule::table_max_entries(const string &name) const {ize_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}","children":[],"id":"138","children_ids":[],"type":"method","name":"BPFModule::table_max_entries(const string &name)","body":"size_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}","line_start":534,"line_end":536,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_max_entries(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_max_entries(const string &name) const {","start_statement_line_start":534,"start_statement_line_end":534,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":536,"end_statement_line_end":536,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":16846,"start_statement_char_start":16846,"start_statement_char_end":16909,"start_statement_char_in_start":0,"start_statement_char_in_end":63,"char_end":16955,"end_statement_char_start":16954,"end_statement_char_end":16955,"end_statement_char_in_start":108,"end_statement_char_in_end":109},{"body_character":"size_t BPFModule::table_max_entries(size_t id) const {ize_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}","children":[],"id":"139","children_ids":[],"type":"method","name":"BPFModule::table_max_entries(size_t id)","body":"size_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}","line_start":538,"line_end":541,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_max_entries(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_max_entries(size_t id) const {","start_statement_line_start":538,"start_statement_line_end":538,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":541,"end_statement_line_end":541,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":16957,"start_statement_char_start":16957,"start_statement_char_end":17011,"start_statement_char_in_start":0,"start_statement_char_in_end":54,"char_end":17089,"end_statement_char_start":17088,"end_statement_char_end":17089,"end_statement_char_in_start":131,"end_statement_char_in_end":132},{"body_character":"const char * BPFModule::table_name(size_t id) const {onst char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}","children":[],"id":"140","children_ids":[],"type":"method","name":"BPFModule::table_name(size_t id)","body":"const char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}","line_start":543,"line_end":546,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::table_name(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::table_name(size_t id) const {","start_statement_line_start":543,"start_statement_line_end":543,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":546,"end_statement_line_end":546,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":17091,"start_statement_char_start":17091,"start_statement_char_end":17144,"start_statement_char_in_start":0,"start_statement_char_in_end":53,"char_end":17229,"end_statement_char_start":17228,"end_statement_char_end":17229,"end_statement_char_in_start":137,"end_statement_char_in_end":138},{"body_character":"const char * BPFModule::table_key_desc(size_t id) const {onst char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}","children":[],"id":"141","children_ids":[],"type":"method","name":"BPFModule::table_key_desc(size_t id)","body":"const char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}","line_start":548,"line_end":552,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::table_key_desc(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::table_key_desc(size_t id) const {","start_statement_line_start":548,"start_statement_line_end":548,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":552,"end_statement_line_end":552,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":17231,"start_statement_char_start":17231,"start_statement_char_end":17288,"start_statement_char_in_start":0,"start_statement_char_in_end":57,"char_end":17410,"end_statement_char_start":17409,"end_statement_char_end":17410,"end_statement_char_in_start":178,"end_statement_char_in_end":179},{"body_character":"const char * BPFModule::table_key_desc(const string &name) const {onst char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}","children":[],"id":"142","children_ids":[],"type":"method","name":"BPFModule::table_key_desc(const string &name)","body":"const char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}","line_start":554,"line_end":556,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::table_key_desc(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::table_key_desc(const string &name) const {","start_statement_line_start":554,"start_statement_line_end":554,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":556,"end_statement_line_end":556,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":17412,"start_statement_char_start":17412,"start_statement_char_end":17478,"start_statement_char_in_start":0,"start_statement_char_in_end":66,"char_end":17521,"end_statement_char_start":17520,"end_statement_char_end":17521,"end_statement_char_in_start":108,"end_statement_char_in_end":109},{"body_character":"const char * BPFModule::table_leaf_desc(size_t id) const {onst char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}","children":[],"id":"143","children_ids":[],"type":"method","name":"BPFModule::table_leaf_desc(size_t id)","body":"const char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}","line_start":558,"line_end":562,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::table_leaf_desc(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::table_leaf_desc(size_t id) const {","start_statement_line_start":558,"start_statement_line_end":558,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":562,"end_statement_line_end":562,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":17523,"start_statement_char_start":17523,"start_statement_char_end":17581,"start_statement_char_in_start":0,"start_statement_char_in_end":58,"char_end":17704,"end_statement_char_start":17703,"end_statement_char_end":17704,"end_statement_char_in_start":180,"end_statement_char_in_end":181},{"body_character":"const char * BPFModule::table_leaf_desc(const string &name) const {onst char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}","children":[],"id":"144","children_ids":[],"type":"method","name":"BPFModule::table_leaf_desc(const string &name)","body":"const char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}","line_start":564,"line_end":566,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"const char * BPFModule::table_leaf_desc(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"const char * BPFModule::table_leaf_desc(const string &name) const {","start_statement_line_start":564,"start_statement_line_end":564,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":566,"end_statement_line_end":566,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":17706,"start_statement_char_start":17706,"start_statement_char_end":17773,"start_statement_char_in_start":0,"start_statement_char_in_end":67,"char_end":17817,"end_statement_char_start":17816,"end_statement_char_end":17817,"end_statement_char_in_start":110,"end_statement_char_in_end":111},{"body_character":"size_t BPFModule::table_key_size(size_t id) const {ize_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}","children":[],"id":"145","children_ids":[],"type":"method","name":"BPFModule::table_key_size(size_t id)","body":"size_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}","line_start":567,"line_end":570,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_key_size(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_key_size(size_t id) const {","start_statement_line_start":567,"start_statement_line_end":567,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":570,"end_statement_line_end":570,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":17818,"start_statement_char_start":17818,"start_statement_char_end":17869,"start_statement_char_in_start":0,"start_statement_char_in_end":51,"char_end":17944,"end_statement_char_start":17943,"end_statement_char_end":17944,"end_statement_char_in_start":125,"end_statement_char_in_end":126},{"body_character":"size_t BPFModule::table_key_size(const string &name) const {ize_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}","children":[],"id":"146","children_ids":[],"type":"method","name":"BPFModule::table_key_size(const string &name)","body":"size_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}","line_start":571,"line_end":573,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_key_size(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_key_size(const string &name) const {","start_statement_line_start":571,"start_statement_line_end":571,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":573,"end_statement_line_end":573,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":17945,"start_statement_char_start":17945,"start_statement_char_end":18005,"start_statement_char_in_start":0,"start_statement_char_in_end":60,"char_end":18048,"end_statement_char_start":18047,"end_statement_char_end":18048,"end_statement_char_in_start":102,"end_statement_char_in_end":103},{"body_character":"size_t BPFModule::table_leaf_size(size_t id) const {ize_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}","children":[],"id":"147","children_ids":[],"type":"method","name":"BPFModule::table_leaf_size(size_t id)","body":"size_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}","line_start":575,"line_end":578,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_leaf_size(size_t id) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_leaf_size(size_t id) const {","start_statement_line_start":575,"start_statement_line_end":575,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":578,"end_statement_line_end":578,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":18050,"start_statement_char_start":18050,"start_statement_char_end":18102,"start_statement_char_in_start":0,"start_statement_char_in_end":52,"char_end":18178,"end_statement_char_start":18177,"end_statement_char_end":18178,"end_statement_char_in_start":127,"end_statement_char_in_end":128},{"body_character":"size_t BPFModule::table_leaf_size(const string &name) const {ize_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}","children":[],"id":"148","children_ids":[],"type":"method","name":"BPFModule::table_leaf_size(const string &name)","body":"size_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}","line_start":579,"line_end":581,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"size_t BPFModule::table_leaf_size(const string &name) const {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"size_t BPFModule::table_leaf_size(const string &name) const {","start_statement_line_start":579,"start_statement_line_end":579,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":581,"end_statement_line_end":581,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":18179,"start_statement_char_start":18179,"start_statement_char_end":18240,"start_statement_char_in_start":0,"start_statement_char_in_end":61,"char_end":18284,"end_statement_char_start":18283,"end_statement_char_end":18284,"end_statement_char_in_start":104,"end_statement_char_in_end":105},{"body_character":"{\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n}","children":[{"body_character":"{\n  }","children":[],"id":"150","children_ids":[],"type":"statement","name":null,"body":"{\n  }","line_start":585,"line_end":586,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":585,"start_statement_line_end":585,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":586,"end_statement_line_end":586,"end_statement_line_in_start":2,"end_statement_line_in_end":2,"char_start":18425,"start_statement_char_start":18425,"start_statement_char_end":18426,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":18430,"end_statement_char_start":18429,"end_statement_char_end":18430,"end_statement_char_in_start":4,"end_statement_char_in_end":5}],"id":"149","children_ids":["150"],"type":"statement","name":null,"body":"{\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n}","line_start":583,"line_end":590,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":583,"start_statement_line_end":583,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":590,"end_statement_line_end":590,"end_statement_line_in_start":8,"end_statement_line_in_end":8,"char_start":18307,"start_statement_char_start":18307,"start_statement_char_end":18308,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":18512,"end_statement_char_start":18511,"end_statement_char_end":18512,"end_statement_char_in_start":204,"end_statement_char_in_end":205},{"body_character":"int BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {nt BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf);\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }","children":[],"id":"152","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }","line_start":595,"line_end":598,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":595,"start_statement_line_end":595,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":598,"end_statement_line_end":598,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":18711,"start_statement_char_start":18711,"start_statement_char_end":18712,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":18784,"end_statement_char_start":18783,"end_statement_char_end":18784,"end_statement_char_in_start":72,"end_statement_char_in_end":73},{"body_character":"{\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n);\n    return -1;\n  }","children":[],"id":"153","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n\");\n    return -1;\n  }","line_start":600,"line_end":603,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":600,"start_statement_line_end":600,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":603,"end_statement_line_end":603,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":18881,"start_statement_char_start":18881,"start_statement_char_end":18882,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":18968,"end_statement_char_start":18967,"end_statement_char_end":18968,"end_statement_char_in_start":86,"end_statement_char_in_end":87},{"body_character":"{\n    perror(\"snprintf);\n    return -1;\n  }","children":[],"id":"154","children_ids":[],"type":"statement","name":null,"body":"{\n    perror(\"snprintf\");\n    return -1;\n  }","line_start":605,"line_end":608,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":605,"start_statement_line_end":605,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":608,"end_statement_line_end":608,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19019,"start_statement_char_start":19019,"start_statement_char_end":19020,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19063,"end_statement_char_start":19062,"end_statement_char_end":19063,"end_statement_char_in_start":43,"end_statement_char_in_end":44},{"body_character":"{\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }","children":[],"id":"155","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }","line_start":609,"line_end":612,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":609,"start_statement_line_end":609,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":612,"end_statement_line_end":612,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19092,"start_statement_char_start":19092,"start_statement_char_end":19093,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19171,"end_statement_char_start":19170,"end_statement_char_end":19171,"end_statement_char_in_start":78,"end_statement_char_in_end":79}],"id":"151","children_ids":["152","153","154","155"],"type":"method","name":"BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key)","body":"int BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}","line_start":592,"line_end":614,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {","start_statement_line_start":592,"start_statement_line_end":592,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":614,"end_statement_line_end":614,"end_statement_line_in_start":23,"end_statement_line_in_end":23,"char_start":18515,"start_statement_char_start":18515,"start_statement_char_end":18602,"start_statement_char_in_start":0,"start_statement_char_in_end":87,"char_end":19185,"end_statement_char_start":19184,"end_statement_char_end":19185,"end_statement_char_in_start":669,"end_statement_char_in_end":670},{"body_character":"int BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {nt BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf);\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Key snprintf not available\\n);\n    return -1;\n  }","children":[],"id":"157","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }","line_start":619,"line_end":622,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":619,"start_statement_line_end":619,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":622,"end_statement_line_end":622,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19386,"start_statement_char_start":19386,"start_statement_char_end":19387,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19459,"end_statement_char_start":19458,"end_statement_char_end":19459,"end_statement_char_in_start":72,"end_statement_char_in_end":73},{"body_character":"{\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n);\n    return -1;\n  }","children":[],"id":"158","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n\");\n    return -1;\n  }","line_start":624,"line_end":627,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":624,"start_statement_line_end":624,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":627,"end_statement_line_end":627,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19557,"start_statement_char_start":19557,"start_statement_char_end":19558,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19645,"end_statement_char_start":19644,"end_statement_char_end":19645,"end_statement_char_in_start":87,"end_statement_char_in_end":88},{"body_character":"{\n    perror(\"snprintf);\n    return -1;\n  }","children":[],"id":"159","children_ids":[],"type":"statement","name":null,"body":"{\n    perror(\"snprintf\");\n    return -1;\n  }","line_start":629,"line_end":632,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":629,"start_statement_line_end":629,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":632,"end_statement_line_end":632,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19697,"start_statement_char_start":19697,"start_statement_char_end":19698,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19741,"end_statement_char_start":19740,"end_statement_char_end":19741,"end_statement_char_in_start":43,"end_statement_char_in_end":44},{"body_character":"{\n    fprintf(stderr, \"snprintf ran out of buffer space\\n);\n    return -1;\n  }","children":[],"id":"160","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }","line_start":633,"line_end":636,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":633,"start_statement_line_end":633,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":636,"end_statement_line_end":636,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":19770,"start_statement_char_start":19770,"start_statement_char_end":19771,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":19849,"end_statement_char_start":19848,"end_statement_char_end":19849,"end_statement_char_in_start":78,"end_statement_char_in_end":79}],"id":"156","children_ids":["157","158","159","160"],"type":"method","name":"BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf)","body":"int BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}","line_start":616,"line_end":638,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {","start_statement_line_start":616,"start_statement_line_end":616,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":638,"end_statement_line_end":638,"end_statement_line_in_start":23,"end_statement_line_in_end":23,"char_start":19187,"start_statement_char_start":19187,"start_statement_char_end":19276,"start_statement_char_in_start":0,"start_statement_char_in_end":89,"char_end":19863,"end_statement_char_start":19862,"end_statement_char_end":19863,"end_statement_char_in_start":675,"end_statement_char_in_end":676},{"body_character":"int BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {nt BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf);\n    return -1;\n  }\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }","children":[],"id":"162","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }","line_start":643,"line_end":646,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":643,"start_statement_line_end":643,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":646,"end_statement_line_end":646,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20047,"start_statement_char_start":20047,"start_statement_char_end":20048,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20118,"end_statement_char_start":20117,"end_statement_char_end":20118,"end_statement_char_in_start":70,"end_statement_char_in_end":71},{"body_character":"{\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n);\n    return -1;\n  }","children":[],"id":"163","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n\");\n    return -1;\n  }","line_start":649,"line_end":652,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":649,"start_statement_line_end":649,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":652,"end_statement_line_end":652,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20210,"start_statement_char_start":20210,"start_statement_char_end":20211,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20295,"end_statement_char_start":20294,"end_statement_char_end":20295,"end_statement_char_in_start":84,"end_statement_char_in_end":85},{"body_character":"{\n    perror(\"sscanf);\n    return -1;\n  }","children":[],"id":"164","children_ids":[],"type":"statement","name":null,"body":"{\n    perror(\"sscanf\");\n    return -1;\n  }","line_start":654,"line_end":657,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":654,"start_statement_line_end":654,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":657,"end_statement_line_end":657,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20343,"start_statement_char_start":20343,"start_statement_char_end":20344,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20385,"end_statement_char_start":20384,"end_statement_char_end":20385,"end_statement_char_in_start":41,"end_statement_char_in_end":42}],"id":"161","children_ids":["162","163","164"],"type":"method","name":"BPFModule::table_key_scanf(size_t id, const char *key_str, void *key)","body":"int BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}","line_start":640,"line_end":659,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {","start_statement_line_start":640,"start_statement_line_end":640,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":659,"end_statement_line_end":659,"end_statement_line_in_start":20,"end_statement_line_in_end":20,"char_start":19865,"start_statement_char_start":19865,"start_statement_char_end":19940,"start_statement_char_in_start":0,"start_statement_char_in_end":75,"char_end":20399,"end_statement_char_start":20398,"end_statement_char_end":20399,"end_statement_char_in_start":533,"end_statement_char_in_end":534},{"body_character":"int BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {nt BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n);\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf);\n    return -1;\n  }\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Key sscanf not available\\n);\n    return -1;\n  }","children":[],"id":"166","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }","line_start":664,"line_end":667,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":664,"start_statement_line_end":664,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":667,"end_statement_line_end":667,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20587,"start_statement_char_start":20587,"start_statement_char_end":20588,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20658,"end_statement_char_start":20657,"end_statement_char_end":20658,"end_statement_char_in_start":70,"end_statement_char_in_end":71},{"body_character":"{\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n);\n    return -1;\n  }","children":[],"id":"167","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n\");\n    return -1;\n  }","line_start":670,"line_end":673,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":670,"start_statement_line_end":670,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":673,"end_statement_line_end":673,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20751,"start_statement_char_start":20751,"start_statement_char_end":20752,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20837,"end_statement_char_start":20836,"end_statement_char_end":20837,"end_statement_char_in_start":85,"end_statement_char_in_end":86},{"body_character":"{\n    perror(\"sscanf);\n    return -1;\n  }","children":[],"id":"168","children_ids":[],"type":"statement","name":null,"body":"{\n    perror(\"sscanf\");\n    return -1;\n  }","line_start":675,"line_end":678,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":675,"start_statement_line_end":675,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":678,"end_statement_line_end":678,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":20887,"start_statement_char_start":20887,"start_statement_char_end":20888,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":20929,"end_statement_char_start":20928,"end_statement_char_end":20929,"end_statement_char_in_start":41,"end_statement_char_in_end":42}],"id":"165","children_ids":["166","167","168"],"type":"method","name":"BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf)","body":"int BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}","line_start":661,"line_end":680,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"int BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {","end_statement":"}","start_statement_regexp":"/[a-zA-Z]{1}[a-zA-Z0-9_<>\\s\\*:~]+\\s+([a-zA-Z0-9_\\*:]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"int BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {","start_statement_line_start":661,"start_statement_line_end":661,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":680,"end_statement_line_end":680,"end_statement_line_in_start":20,"end_statement_line_in_end":20,"char_start":20401,"start_statement_char_start":20401,"start_statement_char_end":20479,"start_statement_char_in_start":0,"start_statement_char_in_end":78,"char_end":20943,"end_statement_char_start":20942,"end_statement_char_end":20943,"end_statement_char_in_start":541,"end_statement_char_in_end":542},{"body_character":"/// load a B file, which comes in two parts\n","children":[],"id":"169","children_ids":[],"type":"comment","name":null,"body":"// load a B file, which comes in two parts\n","line_start":682,"line_end":682,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"       ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":682,"start_statement_line_end":682,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":681,"end_statement_line_end":682,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":20945,"start_statement_char_start":20945,"start_statement_char_end":20947,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":20988,"end_statement_char_start":20987,"end_statement_char_end":20988,"end_statement_char_in_start":42,"end_statement_char_in_end":43},{"body_character":"BPFModule::load_b(const string &filename, const string &proto_filename) {PFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n);\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h);\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h);\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }","children":[],"id":"171","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }","line_start":684,"line_end":687,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":684,"start_statement_line_end":684,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":687,"end_statement_line_end":687,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":21092,"start_statement_char_start":21092,"start_statement_char_end":21093,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":21166,"end_statement_char_start":21165,"end_statement_char_end":21166,"end_statement_char_in_start":73,"end_statement_char_in_end":74},{"body_character":"{\n    fprintf(stderr, \"Invalid filenames\\n);\n    return -1;\n  }","children":[],"id":"172","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Invalid filenames\\n\");\n    return -1;\n  }","line_start":688,"line_end":691,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":688,"start_statement_line_end":688,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":691,"end_statement_line_end":691,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":21217,"start_statement_char_start":21217,"start_statement_char_end":21218,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":21281,"end_statement_char_start":21280,"end_statement_char_end":21281,"end_statement_char_in_start":63,"end_statement_char_in_end":64},{"body_character":"/// Helpers are inlined in the following file (C). Load the definitions and\n","children":[],"id":"173","children_ids":[],"type":"comment","name":null,"body":"// Helpers are inlined in the following file (C). Load the definitions and\n","line_start":693,"line_end":693,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"  ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":693,"start_statement_line_end":693,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":692,"end_statement_line_end":693,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":21285,"start_statement_char_start":21285,"start_statement_char_end":21287,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":21360,"end_statement_char_start":21359,"end_statement_char_end":21360,"end_statement_char_in_start":74,"end_statement_char_in_end":75},{"body_character":"/// pass the partially compiled module to the B frontend to continue with.\n","children":[],"id":"174","children_ids":[],"type":"comment","name":null,"body":"// pass the partially compiled module to the B frontend to continue with.\n","line_start":694,"line_end":694,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"     ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":694,"start_statement_line_end":694,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":693,"end_statement_line_end":694,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":21362,"start_statement_char_start":21362,"start_statement_char_end":21364,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":21436,"end_statement_char_start":21435,"end_statement_char_end":21436,"end_statement_char_in_start":73,"end_statement_char_in_end":74},{"body_character":"{\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h);\n    return -1;\n  }","children":[],"id":"175","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h\");\n    return -1;\n  }","line_start":696,"line_end":699,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":696,"start_statement_line_end":696,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":699,"end_statement_line_end":699,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":21571,"start_statement_char_start":21571,"start_statement_char_end":21572,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":21653,"end_statement_char_start":21652,"end_statement_char_end":21653,"end_statement_char_in_start":81,"end_statement_char_in_end":82}],"id":"170","children_ids":["171","172","173","174","175"],"type":"method","name":"BPFModule::load_b(const string &filename, const string &proto_filename)","body":"BPFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n\");\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h\");\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h\");\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","line_start":683,"line_end":711,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"BPFModule::load_b(const string &filename, const string &proto_filename) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::load_b(const string &filename, const string &proto_filename) {","start_statement_line_start":683,"start_statement_line_end":683,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":711,"end_statement_line_end":711,"end_statement_line_in_start":29,"end_statement_line_in_end":29,"char_start":20992,"start_statement_char_start":20992,"start_statement_char_end":21065,"start_statement_char_in_start":0,"start_statement_char_in_end":73,"char_end":21948,"end_statement_char_start":21947,"end_statement_char_end":21948,"end_statement_char_in_start":955,"end_statement_char_in_end":956},{"body_character":"/// load a C file\n","children":[],"id":"176","children_ids":[],"type":"comment","name":null,"body":"// load a C file\n","line_start":713,"line_end":713,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"         ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":713,"start_statement_line_end":713,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":712,"end_statement_line_end":713,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":21950,"start_statement_char_start":21950,"start_statement_char_end":21952,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":21967,"end_statement_char_start":21966,"end_statement_char_end":21967,"end_statement_char_in_start":16,"end_statement_char_in_end":17},{"body_character":"BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {PFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n);\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }","children":[],"id":"178","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }","line_start":715,"line_end":718,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":715,"start_statement_line_end":715,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":718,"end_statement_line_end":718,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":22076,"start_statement_char_start":22076,"start_statement_char_end":22077,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":22150,"end_statement_char_start":22149,"end_statement_char_end":22150,"end_statement_char_in_start":73,"end_statement_char_in_end":74},{"body_character":"{\n    fprintf(stderr, \"Invalid filename\\n);\n    return -1;\n  }","children":[],"id":"179","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Invalid filename\\n\");\n    return -1;\n  }","line_start":719,"line_end":722,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":719,"start_statement_line_end":719,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":722,"end_statement_line_end":722,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":22175,"start_statement_char_start":22175,"start_statement_char_end":22176,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":22238,"end_statement_char_start":22237,"end_statement_char_end":22238,"end_statement_char_in_start":62,"end_statement_char_in_end":63}],"id":"177","children_ids":["178","179"],"type":"method","name":"BPFModule::load_c(const string &filename, const char *cflags[], int ncflags)","body":"BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","line_start":714,"line_end":730,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {","start_statement_line_start":714,"start_statement_line_end":714,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":730,"end_statement_line_end":730,"end_statement_line_in_start":17,"end_statement_line_in_end":17,"char_start":21971,"start_statement_char_start":21971,"start_statement_char_end":22049,"start_statement_char_in_start":0,"start_statement_char_in_end":78,"char_end":22412,"end_statement_char_start":22411,"end_statement_char_end":22412,"end_statement_char_in_start":440,"end_statement_char_in_end":441},{"body_character":"/// load a C text string\n","children":[],"id":"180","children_ids":[],"type":"comment","name":null,"body":"// load a C text string\n","line_start":732,"line_end":732,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"         ","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":732,"start_statement_line_end":732,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":731,"end_statement_line_end":732,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":22414,"start_statement_char_start":22414,"start_statement_char_end":22416,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":22438,"end_statement_char_start":22437,"end_statement_char_end":22438,"end_statement_char_in_start":23,"end_statement_char_in_end":24},{"body_character":"BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {PFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","children":[{"body_character":"{\n    fprintf(stderr, \"Program already initialized\\n);\n    return -1;\n  }","children":[],"id":"182","children_ids":[],"type":"statement","name":null,"body":"{\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }","line_start":734,"line_end":737,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":734,"start_statement_line_end":734,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":737,"end_statement_line_end":737,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":22548,"start_statement_char_start":22548,"start_statement_char_end":22549,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":22622,"end_statement_char_start":22621,"end_statement_char_end":22622,"end_statement_char_in_start":73,"end_statement_char_in_end":74}],"id":"181","children_ids":["182"],"type":"method","name":"BPFModule::load_string(const string &text, const char *cflags[], int ncflags)","body":"BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}","line_start":733,"line_end":746,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {","end_statement":"}","start_statement_regexp":"/([a-zA-Z0-9_\\*:~]+)\\s*\\(([^()]|\\n)*?\\)[a-zA-Z0-9_\\s\\*:(),]*{/","start_statement_matched":"BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {","start_statement_line_start":733,"start_statement_line_end":733,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":746,"end_statement_line_end":746,"end_statement_line_in_start":14,"end_statement_line_in_end":14,"char_start":22442,"start_statement_char_start":22442,"start_statement_char_end":22521,"start_statement_char_in_start":0,"start_statement_char_in_end":79,"char_end":22792,"end_statement_char_start":22791,"end_statement_char_end":22792,"end_statement_char_in_start":349,"end_statement_char_in_end":350}],"id":"38","children_ids":["39","40","41","42","43","44","45","46","47","48","49","50","51","52","62","64","67","72","73","80","93","104","105","106","107","108","109","110","111","112","117","118","121","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","151","156","161","165","169","170","176","177","180","181"],"type":"namespace","name":"ebpf","body":"namespace ebpf {\n\nusing std::get;\nusing std::make_tuple;\nusing std::map;\nusing std::move;\nusing std::string;\nusing std::tuple;\nusing std::unique_ptr;\nusing std::vector;\nusing namespace llvm;\n\ntypedef int (* sscanf_fn) (const char *, void *);\ntypedef int (* snprintf_fn) (char *, size_t, const void *);\n\nconst string BPFModule::FN_PREFIX = BPF_FN_PREFIX;\n\n// Snooping  to remember the sections as the JIT creates them\nclass MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n};\n\nBPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}\n\nBPFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}\n\nstatic void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf\");\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf\", mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}\n\n// recursive helper to capture the arguments\nstatic void parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ \";\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"}\";\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ \";\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"]\";\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x\";\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh\";\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h\";\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%\";\n    else\n      *fmt += \"%l\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}\n\nFunction * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader\" + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n\", vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf\");\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf\", mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then\", fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}\n\nFunction * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer\" + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len\");\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n\", vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf\");\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf\", mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}\n\nunique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n  return engine;\n}\n\n// load an entire c file as a module\nint BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}\n\n// NOTE: this is a duplicate of the above, but planning to deprecate if we\n// settle on clang as the frontend\n\n// Load in a pre-built list of functions into the initial Module object, then\n// build an ExecutionEngine.\nint BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}\n\nint BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf\", *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}\n\nvoid BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}\n\nint BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}\n\nint BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128\");\n  mod->setTargetTriple(\"bpf-pc-linux\");\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf\");\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}\n\nsize_t BPFModule::num_functions() const {\n  return function_names_.size();\n}\n\nconst char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}\n\nuint8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}\n\nuint8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}\n\nsize_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}\n\nsize_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}\n\nchar * BPFModule::license() const {\n  auto section = sections_.find(\"license\");\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}\n\nunsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version\");\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}\n\nsize_t BPFModule::num_tables() const {\n  return tables_->size();\n}\n\nsize_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}\n\nint BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}\n\nint BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}\n\nint BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}\n\nint BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}\n\nsize_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}\n\nsize_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}\n\nconst char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}\n\nconst char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}\n\nconst char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}\n\nconst char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}\n\nconst char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}\nsize_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}\nsize_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}\n\nsize_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}\nsize_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}\n\nstruct TableIterator {\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n};\n\nint BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\n// load a B file, which comes in two parts\nint BPFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n\");\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h\");\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h\");\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C file\nint BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C text string\nint BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n}","line_start":57,"line_end":748,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":" ","start_statement":"namespace ebpf {","end_statement":"}","start_statement_regexp":"/namespace\\s+([A-Za-z0-9_\\.]+)\\s?[A-Za-z0-9_\\.\\\\\\s]*{/","start_statement_matched":"namespace ebpf {","start_statement_line_start":57,"start_statement_line_end":57,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":748,"end_statement_line_end":748,"end_statement_line_in_start":692,"end_statement_line_in_end":692,"char_start":1747,"start_statement_char_start":1747,"start_statement_char_end":1763,"start_statement_char_in_start":0,"start_statement_char_in_end":16,"char_end":22795,"end_statement_char_start":22794,"end_statement_char_end":22795,"end_statement_char_in_start":21047,"end_statement_char_in_end":21048},{"body_character":"/// namespace ebpf\n","children":[],"id":"183","children_ids":[],"type":"comment","name":null,"body":"// namespace ebpf\n","line_start":748,"line_end":748,"line_preserve_start_whitespaces":" ","line_preserve_end_whitespaces":"","start_statement":"//","end_statement":"\n","start_statement_regexp":"/\\/\\//","start_statement_matched":"//","start_statement_line_start":748,"start_statement_line_end":748,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":747,"end_statement_line_end":748,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":22796,"start_statement_char_start":22796,"start_statement_char_end":22798,"start_statement_char_in_start":0,"start_statement_char_in_end":2,"char_end":22814,"end_statement_char_start":22813,"end_statement_char_end":22814,"end_statement_char_in_start":17,"end_statement_char_in_end":18}],"id":null,"children_ids":[],"type":"file","name":null,"body":"/*\n * Copyright (c) 2015 PLUMgrid, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <algorithm>\n#include <fcntl.h>\n#include <ftw.h>\n#include <map>\n#include <stdio.h>\n#include <string>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <vector>\n#include <linux/bpf.h>\n\n#include <llvm/ADT/STLExtras.h>\n#include <llvm/ExecutionEngine/MCJIT.h>\n#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n#include <llvm/IRReader/IRReader.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/IRPrintingPasses.h>\n#include <llvm/IR/LegacyPassManager.h>\n#include <llvm/IR/LLVMContext.h>\n#include <llvm/IR/Module.h>\n#include <llvm/IR/Verifier.h>\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/SourceMgr.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/Transforms/IPO.h>\n#include <llvm/Transforms/IPO/PassManagerBuilder.h>\n#include <llvm-c/Transforms/IPO.h>\n\n#include \"exception.h\"\n#include \"frontends/b/loader.h\"\n#include \"frontends/clang/loader.h\"\n#include \"frontends/clang/b_frontend_action.h\"\n#include \"bpf_module.h\"\n#include \"exported_files.h\"\n#include \"kbuild_helper.h\"\n#include \"shared_table.h\"\n#include \"libbpf.h\"\n\nnamespace ebpf {\n\nusing std::get;\nusing std::make_tuple;\nusing std::map;\nusing std::move;\nusing std::string;\nusing std::tuple;\nusing std::unique_ptr;\nusing std::vector;\nusing namespace llvm;\n\ntypedef int (* sscanf_fn) (const char *, void *);\ntypedef int (* snprintf_fn) (char *, size_t, const void *);\n\nconst string BPFModule::FN_PREFIX = BPF_FN_PREFIX;\n\n// Snooping  to remember the sections as the JIT creates them\nclass MyMemoryManager : public SectionMemoryManager {\n public:\n\n  explicit MyMemoryManager(map<string, tuple<uint8_t *, uintptr_t>> *sections)\n      : sections_(sections) {\n  }\n\n  virtual ~MyMemoryManager() {}\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = SectionMemoryManager::allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    //printf(\"allocateCodeSection: %s Addr %p Size %ld Alignment %d SectionID %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool isReadOnly) override {\n    uint8_t *Addr = SectionMemoryManager::allocateDataSection(Size, Alignment, SectionID, SectionName, isReadOnly);\n    //printf(\"allocateDataSection: %s Addr %p Size %ld Alignment %d SectionID %d RO %d\\n\",\n    //       SectionName.str().c_str(), (void *)Addr, Size, Alignment, SectionID, isReadOnly);\n    (*sections_)[SectionName.str()] = make_tuple(Addr, Size);\n    return Addr;\n  }\n  map<string, tuple<uint8_t *, uintptr_t>> *sections_;\n};\n\nBPFModule::BPFModule(unsigned flags)\n    : flags_(flags), ctx_(new LLVMContext) {\n  InitializeNativeTarget();\n  InitializeNativeTargetAsmPrinter();\n  LLVMInitializeBPFTarget();\n  LLVMInitializeBPFTargetMC();\n  LLVMInitializeBPFTargetInfo();\n  LLVMInitializeBPFAsmPrinter();\n  LLVMLinkInMCJIT(); /* call empty function to force linking of MCJIT */\n}\n\nBPFModule::~BPFModule() {\n  engine_.reset();\n  rw_engine_.reset();\n  ctx_.reset();\n  if (tables_) {\n    for (auto table : *tables_) {\n      if (table.is_shared)\n        SharedTables::instance()->remove_fd(table.name);\n    }\n  }\n}\n\nstatic void debug_printf(Module *mod, IRBuilder<> &B, const string &fmt, vector<Value *> args) {\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n  args.insert(args.begin(), B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)})));\n  args.insert(args.begin(), B.getInt64((uintptr_t)stderr));\n  Function *fprintf_fn = mod->getFunction(\"fprintf\");\n  if (!fprintf_fn) {\n    vector<Type *> fprintf_fn_args({B.getInt64Ty(), B.getInt8PtrTy()});\n    FunctionType *fprintf_fn_type = FunctionType::get(B.getInt32Ty(), fprintf_fn_args, /*isvarArg=*/true);\n    fprintf_fn = Function::Create(fprintf_fn_type, GlobalValue::ExternalLinkage, \"fprintf\", mod);\n    fprintf_fn->setCallingConv(CallingConv::C);\n    fprintf_fn->addFnAttr(Attribute::NoUnwind);\n  }\n  B.CreateCall(fprintf_fn, args);\n}\n\n// recursive helper to capture the arguments\nstatic void parse_type(IRBuilder<> &B, vector<Value *> *args, string *fmt,\n                       Type *type, Value *out, bool is_writer) {\n  if (StructType *st = dyn_cast<StructType>(type)) {\n    *fmt += \"{ \";\n    unsigned idx = 0;\n    for (auto field : st->elements()) {\n      parse_type(B, args, fmt, field, B.CreateStructGEP(type, out, idx++), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"}\";\n  } else if (ArrayType *at = dyn_cast<ArrayType>(type)) {\n    *fmt += \"[ \";\n    for (size_t i = 0; i < at->getNumElements(); ++i) {\n      parse_type(B, args, fmt, at->getElementType(), B.CreateStructGEP(type, out, i), is_writer);\n      *fmt += \" \";\n    }\n    *fmt += \"]\";\n  } else if (isa<PointerType>(type)) {\n    *fmt += \"0xl\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n  } else if (IntegerType *it = dyn_cast<IntegerType>(type)) {\n    if (is_writer)\n      *fmt += \"0x\";\n    if (it->getBitWidth() <= 8)\n      *fmt += \"%hh\";\n    else if (it->getBitWidth() <= 16)\n      *fmt += \"%h\";\n    else if (it->getBitWidth() <= 32)\n      *fmt += \"%\";\n    else\n      *fmt += \"%l\";\n    if (is_writer)\n      *fmt += \"x\";\n    else\n      *fmt += \"i\";\n    args->push_back(is_writer ? B.CreateLoad(out) : out);\n  }\n}\n\nFunction * BPFModule::make_reader(Module *mod, Type *type) {\n  auto fn_it = readers_.find(type);\n  if (fn_it != readers_.end())\n    return fn_it->second;\n\n  // int read(const char *in, Type *out) {\n  //   int n = sscanf(in, \"{ %i ... }\", &out->field1, ...);\n  //   if (n != num_fields) return -1;\n  //   return 0;\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"reader\" + std::to_string(readers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  BasicBlock *label_exit = BasicBlock::Create(*ctx_, \"exit\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_in, nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_out, false);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[1] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%p %p\\n\", vector<Value *>({arg_in, arg_out}));\n\n  vector<Type *> sscanf_fn_args({B.getInt8PtrTy(), B.getInt8PtrTy()});\n  FunctionType *sscanf_fn_type = FunctionType::get(B.getInt32Ty(), sscanf_fn_args, /*isVarArg=*/true);\n  Function *sscanf_fn = mod->getFunction(\"sscanf\");\n  if (!sscanf_fn)\n    sscanf_fn = Function::Create(sscanf_fn_type, GlobalValue::ExternalLinkage, \"sscanf\", mod);\n  sscanf_fn->setCallingConv(CallingConv::C);\n  sscanf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(sscanf_fn, args);\n  call->setTailCall(true);\n\n  BasicBlock *label_then = BasicBlock::Create(*ctx_, \"then\", fn);\n\n  Value *is_neq = B.CreateICmpNE(call, B.getInt32(args.size() - 2));\n  B.CreateCondBr(is_neq, label_then, label_exit);\n\n  B.SetInsertPoint(label_then);\n  B.CreateRet(B.getInt32(-1));\n\n  B.SetInsertPoint(label_exit);\n  B.CreateRet(B.getInt32(0));\n\n  readers_[type] = fn;\n  return fn;\n}\n\nFunction * BPFModule::make_writer(Module *mod, Type *type) {\n  auto fn_it = writers_.find(type);\n  if (fn_it != writers_.end())\n    return fn_it->second;\n\n  // int write(int len, char *out, Type *in) {\n  //   return snprintf(out, len, \"{ %i ... }\", out->field1, ...);\n  // }\n\n  IRBuilder<> B(*ctx_);\n\n  vector<Type *> fn_args({B.getInt8PtrTy(), B.getInt64Ty(), PointerType::getUnqual(type)});\n  FunctionType *fn_type = FunctionType::get(B.getInt32Ty(), fn_args, /*isVarArg=*/false);\n  Function *fn = Function::Create(fn_type, GlobalValue::ExternalLinkage,\n                                  \"writer\" + std::to_string(writers_.size()), mod);\n  auto arg_it = fn->arg_begin();\n  Argument *arg_out = &*arg_it;\n  ++arg_it;\n  arg_out->setName(\"out\");\n  Argument *arg_len = &*arg_it;\n  ++arg_it;\n  arg_len->setName(\"len\");\n  Argument *arg_in = &*arg_it;\n  ++arg_it;\n  arg_in->setName(\"in\");\n\n  BasicBlock *label_entry = BasicBlock::Create(*ctx_, \"entry\", fn);\n  B.SetInsertPoint(label_entry);\n\n  vector<Value *> args({arg_out, B.CreateZExt(arg_len, B.getInt64Ty()), nullptr});\n  string fmt;\n  parse_type(B, &args, &fmt, type, arg_in, true);\n\n  GlobalVariable *fmt_gvar = B.CreateGlobalString(fmt, \"fmt\");\n\n  args[2] = B.CreateInBoundsGEP(fmt_gvar, vector<Value *>({B.getInt64(0), B.getInt64(0)}));\n\n  if (0)\n    debug_printf(mod, B, \"%d %p %p\\n\", vector<Value *>({arg_len, arg_out, arg_in}));\n\n  vector<Type *> snprintf_fn_args({B.getInt8PtrTy(), B.getInt64Ty(), B.getInt8PtrTy()});\n  FunctionType *snprintf_fn_type = FunctionType::get(B.getInt32Ty(), snprintf_fn_args, /*isVarArg=*/true);\n  Function *snprintf_fn = mod->getFunction(\"snprintf\");\n  if (!snprintf_fn)\n    snprintf_fn = Function::Create(snprintf_fn_type, GlobalValue::ExternalLinkage, \"snprintf\", mod);\n  snprintf_fn->setCallingConv(CallingConv::C);\n  snprintf_fn->addFnAttr(Attribute::NoUnwind);\n\n  CallInst *call = B.CreateCall(snprintf_fn, args);\n  call->setTailCall(true);\n\n  B.CreateRet(call);\n\n  writers_[type] = fn;\n  return fn;\n}\n\nunique_ptr<ExecutionEngine> BPFModule::finalize_rw(unique_ptr<Module> m) {\n  Module *mod = &*m;\n\n  run_pass_manager(*mod);\n\n  string err;\n  EngineBuilder builder(move(m));\n  builder.setErrorStr(&err);\n  builder.setUseOrcMCJITReplacement(true);\n  auto engine = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine)\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n  return engine;\n}\n\n// load an entire c file as a module\nint BPFModule::load_cfile(const string &file, bool in_memory, const char *cflags[], int ncflags) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, file, in_memory, cflags, ncflags))\n    return -1;\n  return 0;\n}\n\n// NOTE: this is a duplicate of the above, but planning to deprecate if we\n// settle on clang as the frontend\n\n// Load in a pre-built list of functions into the initial Module object, then\n// build an ExecutionEngine.\nint BPFModule::load_includes(const string &text) {\n  clang_loader_ = make_unique<ClangLoader>(&*ctx_, flags_);\n  if (clang_loader_->parse(&mod_, &tables_, text, true, nullptr, 0))\n    return -1;\n  return 0;\n}\n\nint BPFModule::annotate() {\n  for (auto fn = mod_->getFunctionList().begin(); fn != mod_->getFunctionList().end(); ++fn)\n    fn->addFnAttr(Attribute::AlwaysInline);\n\n  // separate module to hold the reader functions\n  auto m = make_unique<Module>(\"sscanf\", *ctx_);\n\n  size_t id = 0;\n  for (auto &table : *tables_) {\n    table_names_[table.name] = id++;\n    GlobalValue *gvar = mod_->getNamedValue(table.name);\n    if (!gvar) continue;\n    if (PointerType *pt = dyn_cast<PointerType>(gvar->getType())) {\n      if (StructType *st = dyn_cast<StructType>(pt->getElementType())) {\n        if (st->getNumElements() < 2) continue;\n        Type *key_type = st->elements()[0];\n        Type *leaf_type = st->elements()[1];\n        table.key_sscanf = make_reader(&*m, key_type);\n        if (!table.key_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *key_type << \"\\n\";\n        table.leaf_sscanf = make_reader(&*m, leaf_type);\n        if (!table.leaf_sscanf)\n          errs() << \"Failed to compile sscanf for \" << *leaf_type << \"\\n\";\n        table.key_snprintf = make_writer(&*m, key_type);\n        if (!table.key_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *key_type << \"\\n\";\n        table.leaf_snprintf = make_writer(&*m, leaf_type);\n        if (!table.leaf_snprintf)\n          errs() << \"Failed to compile snprintf for \" << *leaf_type << \"\\n\";\n      }\n    }\n  }\n\n  rw_engine_ = finalize_rw(move(m));\n  if (rw_engine_)\n    rw_engine_->finalizeObject();\n\n  return 0;\n}\n\nvoid BPFModule::dump_ir(Module &mod) {\n  legacy::PassManager PM;\n  PM.add(createPrintModulePass(errs()));\n  PM.run(mod);\n}\n\nint BPFModule::run_pass_manager(Module &mod) {\n  if (verifyModule(mod, &errs())) {\n    if (flags_ & 1)\n      dump_ir(mod);\n    return -1;\n  }\n\n  legacy::PassManager PM;\n  PassManagerBuilder PMB;\n  PMB.OptLevel = 3;\n  PM.add(createFunctionInliningPass());\n  /*\n   * llvm < 4.0 needs\n   * PM.add(createAlwaysInlinerPass());\n   * llvm >= 4.0 needs\n   * PM.add(createAlwaysInlinerLegacyPass());\n   * use below 'stable' workaround\n   */\n  LLVMAddAlwaysInlinerPass(reinterpret_cast<LLVMPassManagerRef>(&PM));\n  PMB.populateModulePassManager(PM);\n  if (flags_ & 1)\n    PM.add(createPrintModulePass(outs()));\n  PM.run(mod);\n  return 0;\n}\n\nint BPFModule::finalize() {\n  Module *mod = &*mod_;\n\n  mod->setDataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128\");\n  mod->setTargetTriple(\"bpf-pc-linux\");\n\n  string err;\n  EngineBuilder builder(move(mod_));\n  builder.setErrorStr(&err);\n  builder.setMCJITMemoryManager(make_unique<MyMemoryManager>(&sections_));\n  builder.setMArch(\"bpf\");\n  builder.setUseOrcMCJITReplacement(true);\n  engine_ = unique_ptr<ExecutionEngine>(builder.create());\n  if (!engine_) {\n    fprintf(stderr, \"Could not create ExecutionEngine: %s\\n\", err.c_str());\n    return -1;\n  }\n\n  if (int rc = run_pass_manager(*mod))\n    return rc;\n\n  engine_->finalizeObject();\n\n  // give functions an id\n  for (auto section : sections_)\n    if (!strncmp(FN_PREFIX.c_str(), section.first.c_str(), FN_PREFIX.size()))\n      function_names_.push_back(section.first);\n\n  return 0;\n}\n\nsize_t BPFModule::num_functions() const {\n  return function_names_.size();\n}\n\nconst char * BPFModule::function_name(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  return function_names_[id].c_str() + FN_PREFIX.size();\n}\n\nuint8_t * BPFModule::function_start(size_t id) const {\n  if (id >= function_names_.size())\n    return nullptr;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return nullptr;\n  return get<0>(section->second);\n}\n\nuint8_t * BPFModule::function_start(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return nullptr;\n\n  return get<0>(section->second);\n}\n\nsize_t BPFModule::function_size(size_t id) const {\n  if (id >= function_names_.size())\n    return 0;\n  auto section = sections_.find(function_names_[id]);\n  if (section == sections_.end())\n    return 0;\n  return get<1>(section->second);\n}\n\nsize_t BPFModule::function_size(const string &name) const {\n  auto section = sections_.find(FN_PREFIX + name);\n  if (section == sections_.end())\n    return 0;\n\n  return get<1>(section->second);\n}\n\nchar * BPFModule::license() const {\n  auto section = sections_.find(\"license\");\n  if (section == sections_.end())\n    return nullptr;\n\n  return (char *)get<0>(section->second);\n}\n\nunsigned BPFModule::kern_version() const {\n  auto section = sections_.find(\"version\");\n  if (section == sections_.end())\n    return 0;\n\n  return *(unsigned *)get<0>(section->second);\n}\n\nsize_t BPFModule::num_tables() const {\n  return tables_->size();\n}\n\nsize_t BPFModule::table_id(const string &name) const {\n  auto it = table_names_.find(name);\n  if (it == table_names_.end()) return ~0ull;\n  return it->second;\n}\n\nint BPFModule::table_fd(const string &name) const {\n  return table_fd(table_id(name));\n}\n\nint BPFModule::table_fd(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].fd;\n}\n\nint BPFModule::table_type(const string &name) const {\n  return table_type(table_id(name));\n}\n\nint BPFModule::table_type(size_t id) const {\n  if (id >= tables_->size()) return -1;\n  return (*tables_)[id].type;\n}\n\nsize_t BPFModule::table_max_entries(const string &name) const {\n  return table_max_entries(table_id(name));\n}\n\nsize_t BPFModule::table_max_entries(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].max_entries;\n}\n\nconst char * BPFModule::table_name(size_t id) const {\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].name.c_str();\n}\n\nconst char * BPFModule::table_key_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].key_desc.c_str();\n}\n\nconst char * BPFModule::table_key_desc(const string &name) const {\n  return table_key_desc(table_id(name));\n}\n\nconst char * BPFModule::table_leaf_desc(size_t id) const {\n  if (b_loader_) return nullptr;\n  if (id >= tables_->size()) return nullptr;\n  return (*tables_)[id].leaf_desc.c_str();\n}\n\nconst char * BPFModule::table_leaf_desc(const string &name) const {\n  return table_leaf_desc(table_id(name));\n}\nsize_t BPFModule::table_key_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].key_size;\n}\nsize_t BPFModule::table_key_size(const string &name) const {\n  return table_key_size(table_id(name));\n}\n\nsize_t BPFModule::table_leaf_size(size_t id) const {\n  if (id >= tables_->size()) return 0;\n  return (*tables_)[id].leaf_size;\n}\nsize_t BPFModule::table_leaf_size(const string &name) const {\n  return table_leaf_size(table_id(name));\n}\n\nstruct TableIterator {\n  TableIterator(size_t key_size, size_t leaf_size)\n      : key(new uint8_t[key_size]), leaf(new uint8_t[leaf_size]) {\n  }\n  unique_ptr<uint8_t[]> key;\n  unique_ptr<uint8_t[]> leaf;\n  uint8_t keyb[512];\n};\n\nint BPFModule::table_key_printf(size_t id, char *buf, size_t buflen, const void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.key_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Key snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, key);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_printf(size_t id, char *buf, size_t buflen, const void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_snprintf) {\n    fprintf(stderr, \"Key snprintf not available\\n\");\n    return -1;\n  }\n  snprintf_fn fn = (snprintf_fn)rw_engine_->getPointerToFunction(desc.leaf_snprintf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf snprintf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(buf, buflen, leaf);\n  if (rc < 0) {\n    perror(\"snprintf\");\n    return -1;\n  }\n  if ((size_t)rc >= buflen) {\n    fprintf(stderr, \"snprintf ran out of buffer space\\n\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_key_scanf(size_t id, const char *key_str, void *key) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.key_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.key_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Key sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(key_str, key);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\nint BPFModule::table_leaf_scanf(size_t id, const char *leaf_str, void *leaf) {\n  if (id >= tables_->size()) return -1;\n  const TableDesc &desc = (*tables_)[id];\n  if (!desc.leaf_sscanf) {\n    fprintf(stderr, \"Key sscanf not available\\n\");\n    return -1;\n  }\n\n  sscanf_fn fn = (sscanf_fn)rw_engine_->getPointerToFunction(desc.leaf_sscanf);\n  if (!fn) {\n    fprintf(stderr, \"Leaf sscanf not available in JIT Engine\\n\");\n    return -1;\n  }\n  int rc = (*fn)(leaf_str, leaf);\n  if (rc != 0) {\n    perror(\"sscanf\");\n    return -1;\n  }\n  return 0;\n}\n\n// load a B file, which comes in two parts\nint BPFModule::load_b(const string &filename, const string &proto_filename) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty() || proto_filename.empty()) {\n    fprintf(stderr, \"Invalid filenames\\n\");\n    return -1;\n  }\n\n  // Helpers are inlined in the following file (C). Load the definitions and\n  // pass the partially compiled module to the B frontend to continue with.\n  auto helpers_h = ExportedFiles::headers().find(\"/virtual/include/bcc/helpers.h\");\n  if (helpers_h == ExportedFiles::headers().end()) {\n    fprintf(stderr, \"Internal error: missing bcc/helpers.h\");\n    return -1;\n  }\n  if (int rc = load_includes(helpers_h->second))\n    return rc;\n\n  b_loader_.reset(new BLoader(flags_));\n  if (int rc = b_loader_->parse(&*mod_, filename, proto_filename, &tables_))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C file\nint BPFModule::load_c(const string &filename, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (filename.empty()) {\n    fprintf(stderr, \"Invalid filename\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(filename, false, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n// load a C text string\nint BPFModule::load_string(const string &text, const char *cflags[], int ncflags) {\n  if (!sections_.empty()) {\n    fprintf(stderr, \"Program already initialized\\n\");\n    return -1;\n  }\n  if (int rc = load_cfile(text, true, cflags, ncflags))\n    return rc;\n  if (int rc = annotate())\n    return rc;\n\n  if (int rc = finalize())\n    return rc;\n  return 0;\n}\n\n} // namespace ebpf\n","line_start":1,"line_end":749,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":null,"end_statement":null,"start_statement_regexp":null,"start_statement_matched":null,"start_statement_line_start":null,"start_statement_line_end":null,"start_statement_line_in_start":null,"start_statement_line_in_end":null,"end_statement_regexp":null,"end_statement_matched":null,"end_statement_line_start":null,"end_statement_line_end":null,"end_statement_line_in_start":null,"end_statement_line_in_end":null}