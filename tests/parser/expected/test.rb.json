{"body_character":"module ActiveRecord\n  class Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  end\nend\n","children":[{"body_character":"module ActiveRecordodule ActiveRecord\n  class Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  end\ne","children":[{"body_character":"class Relationlass Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  e","children":[{"body_character":"class WhereClause lass WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    e","children":[{"body_character":"# :nodoc:\n","children":[],"id":"3","children_ids":[],"type":"comment","name":null,"body":"# :nodoc:\n","line_start":3,"line_end":3,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"       ","start_statement":"#","end_statement":"\n","start_statement_regexp":"/#/","start_statement_matched":"#","start_statement_line_start":3,"start_statement_line_end":3,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/\\n/","end_statement_matched":"\n","end_statement_line_start":2,"end_statement_line_end":3,"end_statement_line_in_start":1,"end_statement_line_in_end":2,"char_start":59,"start_statement_char_start":59,"start_statement_char_end":60,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":69,"end_statement_char_start":68,"end_statement_char_end":69,"end_statement_char_in_start":9,"end_statement_char_in_end":10},{"body_character":"attr_reader :binds\nttr_reader :binds\n","children":[],"id":"4","children_ids":[],"type":"attribute","name":"attr_reader :binds","body":"attr_reader :binds","line_start":4,"line_end":4,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"attr_reader :binds\n","end_statement":"","start_statement_regexp":"/(?!end)([a-zA-Z]{1}[a-zA-Z0-9_\\.\\?@:\\r\\t\\f ]*)\\n/","start_statement_matched":"attr_reader :binds\n","start_statement_line_start":4,"start_statement_line_end":5,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":4,"end_statement_line_end":4,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":75,"start_statement_char_start":75,"start_statement_char_end":94,"start_statement_char_in_start":0,"start_statement_char_in_end":19,"char_end":93,"end_statement_char_start":93,"end_statement_char_end":93,"end_statement_char_in_start":18,"end_statement_char_in_end":18},{"body_character":"to: :predicates\no: :predicates\n","children":[],"id":"5","children_ids":[],"type":"attribute","name":"to: :predicates","body":"to: :predicates","line_start":6,"line_end":6,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"to: :predicates\n","end_statement":"","start_statement_regexp":"/(?!end)([a-zA-Z]{1}[a-zA-Z0-9_\\.\\?@:\\r\\t\\f ]*)\\n/","start_statement_matched":"to: :predicates\n","start_statement_line_start":6,"start_statement_line_end":7,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":6,"end_statement_line_end":6,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":126,"start_statement_char_start":126,"start_statement_char_end":142,"start_statement_char_in_start":0,"start_statement_char_in_end":16,"char_end":141,"end_statement_char_start":141,"end_statement_char_end":141,"end_statement_char_in_start":15,"end_statement_char_in_end":15},{"body_character":"def initialize(predicates, binds)ef initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      e","children":[],"id":"6","children_ids":[],"type":"method","name":"initialize","body":"def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end","line_start":8,"line_end":11,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def initialize(predicates, binds)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def initialize(predicates, binds)","start_statement_line_start":8,"start_statement_line_end":8,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":11,"end_statement_line_end":11,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":149,"start_statement_char_start":149,"start_statement_char_end":182,"start_statement_char_in_start":0,"start_statement_char_in_end":33,"char_end":248,"end_statement_char_start":245,"end_statement_char_end":248,"end_statement_char_in_start":96,"end_statement_char_in_end":99},{"body_character":"def +(other)ef +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      e","children":[],"id":"7","children_ids":[],"type":"method","name":"+","body":"def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end","line_start":13,"line_end":18,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def +(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def +(other)","start_statement_line_start":13,"start_statement_line_end":13,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":18,"end_statement_line_end":18,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":256,"start_statement_char_start":256,"start_statement_char_end":268,"start_statement_char_in_start":0,"start_statement_char_in_end":12,"char_end":385,"end_statement_char_start":382,"end_statement_char_end":385,"end_statement_char_in_start":126,"end_statement_char_in_end":129},{"body_character":"def merge(other)ef merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      e","children":[],"id":"8","children_ids":[],"type":"method","name":"merge","body":"def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end","line_start":20,"line_end":25,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def merge(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def merge(other)","start_statement_line_start":20,"start_statement_line_end":20,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":25,"end_statement_line_end":25,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":393,"start_statement_char_start":393,"start_statement_char_end":409,"start_statement_char_in_start":0,"start_statement_char_in_end":16,"char_end":572,"end_statement_char_start":569,"end_statement_char_end":572,"end_statement_char_in_start":176,"end_statement_char_in_end":179},{"body_character":"def except(*columns)ef except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      e","children":[],"id":"9","children_ids":[],"type":"method","name":"except","body":"def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end","line_start":27,"line_end":32,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def except(*columns)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def except(*columns)","start_statement_line_start":27,"start_statement_line_end":27,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":32,"end_statement_line_end":32,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":580,"start_statement_char_start":580,"start_statement_char_end":600,"start_statement_char_in_start":0,"start_statement_char_in_end":20,"char_end":716,"end_statement_char_start":713,"end_statement_char_end":716,"end_statement_char_in_start":133,"end_statement_char_in_end":136},{"body_character":"def or(other)ef or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      e","children":[{"body_character":" if if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        e","children":[],"id":"11","children_ids":[],"type":"statement","name":null,"body":" if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end","line_start":35,"line_end":44,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":" if ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" if ","start_statement_line_start":35,"start_statement_line_end":35,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":44,"end_statement_line_end":44,"end_statement_line_in_start":10,"end_statement_line_in_end":10,"char_start":745,"start_statement_char_start":745,"start_statement_char_end":749,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":942,"end_statement_char_start":939,"end_statement_char_end":942,"end_statement_char_in_start":194,"end_statement_char_in_end":197}],"id":"10","children_ids":["11"],"type":"method","name":"or","body":"def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end","line_start":34,"line_end":45,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def or(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def or(other)","start_statement_line_start":34,"start_statement_line_end":34,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":45,"end_statement_line_end":45,"end_statement_line_in_start":12,"end_statement_line_in_end":12,"char_start":724,"start_statement_char_start":724,"start_statement_char_end":737,"start_statement_char_in_start":0,"start_statement_char_in_end":13,"char_end":952,"end_statement_char_start":949,"end_statement_char_end":952,"end_statement_char_in_start":225,"end_statement_char_in_end":228},{"body_character":"def to_h(table_name = nil)ef to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      e","children":[{"body_character":" if if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        e","children":[{"body_character":" do do |node|\n            node.left.relation.name == table_name\n          e","children":[],"id":"14","children_ids":[],"type":"statement","name":null,"body":" do |node|\n            node.left.relation.name == table_name\n          end","line_start":50,"line_end":52,"line_preserve_start_whitespaces":"             ","line_preserve_end_whitespaces":"","start_statement":" do ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" do ","start_statement_line_start":50,"start_statement_line_end":50,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":52,"end_statement_line_end":52,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":1109,"start_statement_char_start":1109,"start_statement_char_end":1113,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":1183,"end_statement_char_start":1180,"end_statement_char_end":1183,"end_statement_char_in_start":71,"end_statement_char_in_end":74}],"id":"13","children_ids":["14"],"type":"statement","name":null,"body":" if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end","line_start":49,"line_end":53,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":" if ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" if ","start_statement_line_start":49,"start_statement_line_end":49,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":53,"end_statement_line_end":53,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":1054,"start_statement_char_start":1054,"start_statement_char_end":1058,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":1195,"end_statement_char_start":1192,"end_statement_char_end":1195,"end_statement_char_in_start":138,"end_statement_char_in_end":141},{"body_character":"{ |attr| [attr.name, attr.value] }","children":[],"id":"15","children_ids":[],"type":"statement","name":null,"body":"{ |attr| [attr.name, attr.value] }","line_start":55,"line_end":55,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":55,"start_statement_line_end":55,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":55,"end_statement_line_end":55,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1228,"start_statement_char_start":1228,"start_statement_char_end":1229,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":1262,"end_statement_char_start":1261,"end_statement_char_end":1262,"end_statement_char_in_start":33,"end_statement_char_in_end":34},{"body_character":"{ |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }","children":[{"body_character":"{\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }","children":[{"body_character":" case case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            e","children":[],"id":"18","children_ids":[],"type":"statement","name":null,"body":" case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end","line_start":60,"line_end":64,"line_preserve_start_whitespaces":"            ","line_preserve_end_whitespaces":"","start_statement":" case ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" case ","start_statement_line_start":60,"start_statement_line_end":60,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":64,"end_statement_line_end":64,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":1386,"start_statement_char_start":1386,"start_statement_char_end":1392,"start_statement_char_in_start":0,"start_statement_char_in_end":6,"char_end":1555,"end_statement_char_start":1552,"end_statement_char_end":1555,"end_statement_char_in_start":166,"end_statement_char_in_end":169}],"id":"17","children_ids":["18"],"type":"statement","name":null,"body":"{\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }","line_start":59,"line_end":65,"line_preserve_start_whitespaces":"            ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":59,"start_statement_line_end":59,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":65,"end_statement_line_end":65,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":1373,"start_statement_char_start":1373,"start_statement_char_end":1374,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":1567,"end_statement_char_start":1566,"end_statement_char_end":1567,"end_statement_char_in_start":193,"end_statement_char_in_end":194}],"id":"16","children_ids":["17"],"type":"statement","name":null,"body":"{ |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }","line_start":57,"line_end":66,"line_preserve_start_whitespaces":"         ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":57,"start_statement_line_end":57,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":66,"end_statement_line_end":66,"end_statement_line_in_start":10,"end_statement_line_in_end":10,"char_start":1292,"start_statement_char_start":1292,"start_statement_char_end":1293,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":1578,"end_statement_char_start":1577,"end_statement_char_end":1578,"end_statement_char_in_start":285,"end_statement_char_in_end":286}],"id":"12","children_ids":["13","15","16"],"type":"method","name":"to_h","body":"def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end","line_start":47,"line_end":67,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def to_h(table_name = nil)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def to_h(table_name = nil)","start_statement_line_start":47,"start_statement_line_end":47,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":67,"end_statement_line_end":67,"end_statement_line_in_start":21,"end_statement_line_in_end":21,"char_start":960,"start_statement_char_start":960,"start_statement_char_end":986,"start_statement_char_in_start":0,"start_statement_char_in_end":26,"char_end":1593,"end_statement_char_start":1590,"end_statement_char_end":1593,"end_statement_char_in_start":630,"end_statement_char_in_end":633},{"body_character":"def astef ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      e","children":[],"id":"19","children_ids":[],"type":"method","name":"ast","body":"def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end","line_start":69,"line_end":71,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def ast","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def ast","start_statement_line_start":69,"start_statement_line_end":69,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":71,"end_statement_line_end":71,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":1601,"start_statement_char_start":1601,"start_statement_char_end":1608,"start_statement_char_in_start":0,"start_statement_char_in_end":7,"char_end":1685,"end_statement_char_start":1682,"end_statement_char_end":1685,"end_statement_char_in_start":81,"end_statement_char_in_end":84},{"body_character":"def ==(other)ef ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      e","children":[],"id":"20","children_ids":[],"type":"method","name":"==","body":"def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end","line_start":73,"line_end":77,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def ==(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def ==(other)","start_statement_line_start":73,"start_statement_line_end":73,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":77,"end_statement_line_end":77,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":1693,"start_statement_char_start":1693,"start_statement_char_end":1706,"start_statement_char_in_start":0,"start_statement_char_in_end":13,"char_end":1827,"end_statement_char_start":1824,"end_statement_char_end":1827,"end_statement_char_in_start":131,"end_statement_char_in_end":134},{"body_character":"def invertef invert\n        WhereClause.new(inverted_predicates, binds)\n      e","children":[],"id":"21","children_ids":[],"type":"method","name":"invert","body":"def invert\n        WhereClause.new(inverted_predicates, binds)\n      end","line_start":79,"line_end":81,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def invert","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def invert","start_statement_line_start":79,"start_statement_line_end":79,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":81,"end_statement_line_end":81,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":1835,"start_statement_char_start":1835,"start_statement_char_end":1845,"start_statement_char_in_start":0,"start_statement_char_in_end":10,"char_end":1907,"end_statement_char_start":1904,"end_statement_char_end":1907,"end_statement_char_in_start":69,"end_statement_char_in_end":72},{"body_character":"def self.emptyef self.empty\n        @empty ||= new([], [])\n      e","children":[],"id":"22","children_ids":[],"type":"method","name":"self.empty","body":"def self.empty\n        @empty ||= new([], [])\n      end","line_start":83,"line_end":85,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"def self.empty","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def self.empty","start_statement_line_start":83,"start_statement_line_end":83,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":85,"end_statement_line_end":85,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":1915,"start_statement_char_start":1915,"start_statement_char_end":1929,"start_statement_char_in_start":0,"start_statement_char_in_end":14,"char_end":1970,"end_statement_char_start":1967,"end_statement_char_end":1970,"end_statement_char_in_start":52,"end_statement_char_in_end":55},{"body_character":"protected\nrotected\n","children":[],"id":"23","children_ids":[],"type":"attribute","name":"protected","body":"protected","line_start":87,"line_end":87,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"protected\n","end_statement":"","start_statement_regexp":"/(?!end)([a-zA-Z]{1}[a-zA-Z0-9_\\.\\?@:\\r\\t\\f ]*)\\n/","start_statement_matched":"protected\n","start_statement_line_start":87,"start_statement_line_end":88,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":87,"end_statement_line_end":87,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1978,"start_statement_char_start":1978,"start_statement_char_end":1988,"start_statement_char_in_start":0,"start_statement_char_in_end":10,"char_end":1987,"end_statement_char_start":1987,"end_statement_char_end":1987,"end_statement_char_in_start":9,"end_statement_char_in_end":9},{"body_character":"attr_reader :predicates\nttr_reader :predicates\n","children":[],"id":"24","children_ids":[],"type":"attribute","name":"attr_reader :predicates","body":"attr_reader :predicates","line_start":89,"line_end":89,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"attr_reader :predicates\n","end_statement":"","start_statement_regexp":"/(?!end)([a-zA-Z]{1}[a-zA-Z0-9_\\.\\?@:\\r\\t\\f ]*)\\n/","start_statement_matched":"attr_reader :predicates\n","start_statement_line_start":89,"start_statement_line_end":90,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":89,"end_statement_line_end":89,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":1997,"start_statement_char_start":1997,"start_statement_char_end":2021,"start_statement_char_in_start":0,"start_statement_char_in_end":24,"char_end":2020,"end_statement_char_start":2020,"end_statement_char_end":2020,"end_statement_char_in_start":23,"end_statement_char_in_end":23},{"body_character":"def referenced_columnsef referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        e","children":[{"body_character":" begin\nbegin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          e","children":[{"body_character":"{ |n| equality_node?(n) }","children":[],"id":"27","children_ids":[],"type":"statement","name":null,"body":"{ |n| equality_node?(n) }","line_start":93,"line_end":93,"line_preserve_start_whitespaces":"               ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":93,"start_statement_line_end":93,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":93,"end_statement_line_end":93,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2140,"start_statement_char_start":2140,"start_statement_char_end":2141,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":2165,"end_statement_char_start":2164,"end_statement_char_end":2165,"end_statement_char_in_start":24,"end_statement_char_in_end":25}],"id":"26","children_ids":["27"],"type":"statement","name":null,"body":" begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end","line_start":92,"line_end":95,"line_preserve_start_whitespaces":"            ","line_preserve_end_whitespaces":"","start_statement":" begin\n","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" begin\n","start_statement_line_start":92,"start_statement_line_end":93,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":95,"end_statement_line_end":95,"end_statement_line_in_start":4,"end_statement_line_in_end":4,"char_start":2086,"start_statement_char_start":2086,"start_statement_char_end":2093,"start_statement_char_in_start":0,"start_statement_char_in_end":7,"char_end":2223,"end_statement_char_start":2220,"end_statement_char_end":2223,"end_statement_char_in_start":134,"end_statement_char_in_end":137}],"id":"25","children_ids":["26"],"type":"method","name":"referenced_columns","body":"def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end","line_start":91,"line_end":96,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def referenced_columns","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def referenced_columns","start_statement_line_start":91,"start_statement_line_end":91,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":96,"end_statement_line_end":96,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":2030,"start_statement_char_start":2030,"start_statement_char_end":2052,"start_statement_char_in_start":0,"start_statement_char_in_end":22,"char_end":2235,"end_statement_char_start":2232,"end_statement_char_end":2235,"end_statement_char_in_start":202,"end_statement_char_in_end":205},{"body_character":"private\nrivate\n","children":[],"id":"28","children_ids":[],"type":"attribute","name":"private","body":"private","line_start":98,"line_end":98,"line_preserve_start_whitespaces":"      ","line_preserve_end_whitespaces":"","start_statement":"private\n","end_statement":"","start_statement_regexp":"/(?!end)([a-zA-Z]{1}[a-zA-Z0-9_\\.\\?@:\\r\\t\\f ]*)\\n/","start_statement_matched":"private\n","start_statement_line_start":98,"start_statement_line_end":99,"start_statement_line_in_start":1,"start_statement_line_in_end":2,"end_statement_regexp":null,"end_statement_matched":"","end_statement_line_start":98,"end_statement_line_end":98,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2243,"start_statement_char_start":2243,"start_statement_char_end":2251,"start_statement_char_in_start":0,"start_statement_char_in_end":8,"char_end":2250,"end_statement_char_start":2250,"end_statement_char_end":2250,"end_statement_char_in_start":7,"end_statement_char_in_end":7},{"body_character":"def predicates_unreferenced_by(other)ef predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        e","children":[{"body_character":" do do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          e","children":[],"id":"30","children_ids":[],"type":"statement","name":null,"body":" do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end","line_start":101,"line_end":103,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":" do ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" do ","start_statement_line_start":101,"start_statement_line_end":101,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":103,"end_statement_line_end":103,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":2325,"start_statement_char_start":2325,"start_statement_char_end":2329,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":2421,"end_statement_char_start":2418,"end_statement_char_end":2421,"end_statement_char_in_start":93,"end_statement_char_in_end":96}],"id":"29","children_ids":["30"],"type":"method","name":"predicates_unreferenced_by","body":"def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end","line_start":100,"line_end":104,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def predicates_unreferenced_by(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def predicates_unreferenced_by(other)","start_statement_line_start":100,"start_statement_line_end":100,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":104,"end_statement_line_end":104,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":2260,"start_statement_char_start":2260,"start_statement_char_end":2297,"start_statement_char_in_start":0,"start_statement_char_in_end":37,"char_end":2433,"end_statement_char_start":2430,"end_statement_char_end":2433,"end_statement_char_in_start":170,"end_statement_char_in_end":173},{"body_character":"def equality_nodeef equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        e","children":[],"id":"31","children_ids":[],"type":"method","name":"equality_node","body":"def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end","line_start":106,"line_end":108,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def equality_node","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def equality_node","start_statement_line_start":106,"start_statement_line_end":106,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":108,"end_statement_line_end":108,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":2443,"start_statement_char_start":2443,"start_statement_char_end":2460,"start_statement_char_in_start":0,"start_statement_char_in_end":17,"char_end":2541,"end_statement_char_start":2538,"end_statement_char_end":2541,"end_statement_char_in_start":95,"end_statement_char_in_end":98},{"body_character":"def non_conflicting_binds(other)ef non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        e","children":[{"body_character":"{ |node| node.name.to_s }","children":[],"id":"33","children_ids":[],"type":"statement","name":null,"body":"{ |node| node.name.to_s }","line_start":112,"line_end":112,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":112,"start_statement_line_end":112,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":112,"end_statement_line_end":112,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2677,"start_statement_char_start":2677,"start_statement_char_end":2678,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":2702,"end_statement_char_start":2701,"end_statement_char_end":2702,"end_statement_char_in_start":24,"end_statement_char_in_end":25},{"body_character":"{ |attr| conflicts.include?(attr.name) }","children":[],"id":"34","children_ids":[],"type":"statement","name":null,"body":"{ |attr| conflicts.include?(attr.name) }","line_start":113,"line_end":113,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":113,"start_statement_line_end":113,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":113,"end_statement_line_end":113,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2726,"start_statement_char_start":2726,"start_statement_char_end":2727,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":2766,"end_statement_char_start":2765,"end_statement_char_end":2766,"end_statement_char_in_start":39,"end_statement_char_in_end":40}],"id":"32","children_ids":["33","34"],"type":"method","name":"non_conflicting_binds","body":"def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end","line_start":110,"line_end":114,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def non_conflicting_binds(other)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def non_conflicting_binds(other)","start_statement_line_start":110,"start_statement_line_end":110,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":114,"end_statement_line_end":114,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":2551,"start_statement_char_start":2551,"start_statement_char_end":2583,"start_statement_char_in_start":0,"start_statement_char_in_end":32,"char_end":2778,"end_statement_char_start":2775,"end_statement_char_end":2778,"end_statement_char_in_start":224,"end_statement_char_in_end":227},{"body_character":"def inverted_predicatesef inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        e","children":[{"body_character":"{ |node| invert_predicate(node) }","children":[],"id":"36","children_ids":[],"type":"statement","name":null,"body":"{ |node| invert_predicate(node) }","line_start":117,"line_end":117,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":"{","end_statement":"}","start_statement_regexp":"/{/","start_statement_matched":"{","start_statement_line_start":117,"start_statement_line_end":117,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/}/","end_statement_matched":"}","end_statement_line_start":117,"end_statement_line_end":117,"end_statement_line_in_start":1,"end_statement_line_in_end":1,"char_start":2837,"start_statement_char_start":2837,"start_statement_char_end":2838,"start_statement_char_in_start":0,"start_statement_char_in_end":1,"char_end":2870,"end_statement_char_start":2869,"end_statement_char_end":2870,"end_statement_char_in_start":32,"end_statement_char_in_end":33}],"id":"35","children_ids":["36"],"type":"method","name":"inverted_predicates","body":"def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end","line_start":116,"line_end":118,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def inverted_predicates","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def inverted_predicates","start_statement_line_start":116,"start_statement_line_end":116,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":118,"end_statement_line_end":118,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":2788,"start_statement_char_start":2788,"start_statement_char_end":2811,"start_statement_char_in_start":0,"start_statement_char_in_end":23,"char_end":2882,"end_statement_char_start":2879,"end_statement_char_end":2882,"end_statement_char_in_start":91,"end_statement_char_in_end":94},{"body_character":"def invert_predicate(node)ef invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        e","children":[{"body_character":" case case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          e","children":[],"id":"38","children_ids":[],"type":"statement","name":null,"body":" case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end","line_start":121,"line_end":132,"line_preserve_start_whitespaces":"          ","line_preserve_end_whitespaces":"","start_statement":" case ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" case ","start_statement_line_start":121,"start_statement_line_end":121,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":132,"end_statement_line_end":132,"end_statement_line_in_start":12,"end_statement_line_in_end":12,"char_start":2928,"start_statement_char_start":2928,"start_statement_char_end":2934,"start_statement_char_in_start":0,"start_statement_char_in_end":6,"char_end":3386,"end_statement_char_start":3383,"end_statement_char_end":3386,"end_statement_char_in_start":455,"end_statement_char_in_end":458}],"id":"37","children_ids":["38"],"type":"method","name":"invert_predicate","body":"def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end","line_start":120,"line_end":133,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def invert_predicate(node)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def invert_predicate(node)","start_statement_line_start":120,"start_statement_line_end":120,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":133,"end_statement_line_end":133,"end_statement_line_in_start":14,"end_statement_line_in_end":14,"char_start":2892,"start_statement_char_start":2892,"start_statement_char_end":2918,"start_statement_char_in_start":0,"start_statement_char_in_end":26,"char_end":3398,"end_statement_char_start":3395,"end_statement_char_end":3398,"end_statement_char_in_start":503,"end_statement_char_in_end":506},{"body_character":"def predicates_except(columns)ef predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        e","children":[{"body_character":" do do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          e","children":[{"body_character":" case case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            e","children":[],"id":"41","children_ids":[],"type":"statement","name":null,"body":" case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end","line_start":137,"line_end":141,"line_preserve_start_whitespaces":"            ","line_preserve_end_whitespaces":"","start_statement":" case ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" case ","start_statement_line_start":137,"start_statement_line_end":137,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":141,"end_statement_line_end":141,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":3488,"start_statement_char_start":3488,"start_statement_char_end":3494,"start_statement_char_in_start":0,"start_statement_char_in_end":6,"char_end":3904,"end_statement_char_start":3901,"end_statement_char_end":3904,"end_statement_char_in_start":413,"end_statement_char_in_end":416}],"id":"40","children_ids":["41"],"type":"statement","name":null,"body":" do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end","line_start":136,"line_end":142,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":" do ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" do ","start_statement_line_start":136,"start_statement_line_end":136,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":142,"end_statement_line_end":142,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":3466,"start_statement_char_start":3466,"start_statement_char_end":3470,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":3918,"end_statement_char_start":3915,"end_statement_char_end":3918,"end_statement_char_in_start":449,"end_statement_char_in_end":452}],"id":"39","children_ids":["40"],"type":"method","name":"predicates_except","body":"def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end","line_start":135,"line_end":143,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def predicates_except(columns)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def predicates_except(columns)","start_statement_line_start":135,"start_statement_line_end":135,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":143,"end_statement_line_end":143,"end_statement_line_in_start":9,"end_statement_line_in_end":9,"char_start":3408,"start_statement_char_start":3408,"start_statement_char_end":3438,"start_statement_char_in_start":0,"start_statement_char_in_end":30,"char_end":3930,"end_statement_char_start":3927,"end_statement_char_end":3930,"end_statement_char_in_start":519,"end_statement_char_in_end":522},{"body_character":"def binds_except(columns)ef binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        e","children":[{"body_character":" do do |attr|\n            columns.include?(attr.name)\n          e","children":[],"id":"43","children_ids":[],"type":"statement","name":null,"body":" do |attr|\n            columns.include?(attr.name)\n          end","line_start":146,"line_end":148,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":" do ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" do ","start_statement_line_start":146,"start_statement_line_end":146,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":148,"end_statement_line_end":148,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":3988,"start_statement_char_start":3988,"start_statement_char_end":3992,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":4052,"end_statement_char_start":4049,"end_statement_char_end":4052,"end_statement_char_in_start":61,"end_statement_char_in_end":64}],"id":"42","children_ids":["43"],"type":"method","name":"binds_except","body":"def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end","line_start":145,"line_end":149,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def binds_except(columns)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def binds_except(columns)","start_statement_line_start":145,"start_statement_line_end":145,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":149,"end_statement_line_end":149,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":3940,"start_statement_char_start":3940,"start_statement_char_end":3965,"start_statement_char_in_start":0,"start_statement_char_in_end":25,"char_end":4064,"end_statement_char_start":4061,"end_statement_char_end":4064,"end_statement_char_in_start":121,"end_statement_char_in_end":124},{"body_character":"def predicates_with_wrapped_sql_literalsef predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        e","children":[{"body_character":" do do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          e","children":[{"body_character":" if if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            e","children":[],"id":"46","children_ids":[],"type":"statement","name":null,"body":" if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end","line_start":153,"line_end":157,"line_preserve_start_whitespaces":"            ","line_preserve_end_whitespaces":"","start_statement":" if ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" if ","start_statement_line_start":153,"start_statement_line_end":153,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":157,"end_statement_line_end":157,"end_statement_line_in_start":5,"end_statement_line_in_end":5,"char_start":4171,"start_statement_char_start":4171,"start_statement_char_end":4175,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":4294,"end_statement_char_start":4291,"end_statement_char_end":4294,"end_statement_char_in_start":120,"end_statement_char_in_end":123}],"id":"45","children_ids":["46"],"type":"statement","name":null,"body":" do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end","line_start":152,"line_end":158,"line_preserve_start_whitespaces":"           ","line_preserve_end_whitespaces":"","start_statement":" do ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" do ","start_statement_line_start":152,"start_statement_line_end":152,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":158,"end_statement_line_end":158,"end_statement_line_in_start":7,"end_statement_line_in_end":7,"char_start":4149,"start_statement_char_start":4149,"start_statement_char_end":4153,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":4308,"end_statement_char_start":4305,"end_statement_char_end":4308,"end_statement_char_in_start":156,"end_statement_char_in_end":159}],"id":"44","children_ids":["45"],"type":"method","name":"predicates_with_wrapped_sql_literals","body":"def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end","line_start":151,"line_end":159,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def predicates_with_wrapped_sql_literals","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def predicates_with_wrapped_sql_literals","start_statement_line_start":151,"start_statement_line_end":151,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":159,"end_statement_line_end":159,"end_statement_line_in_start":9,"end_statement_line_in_end":9,"char_start":4074,"start_statement_char_start":4074,"start_statement_char_end":4114,"start_statement_char_in_start":0,"start_statement_char_in_end":40,"char_end":4320,"end_statement_char_start":4317,"end_statement_char_end":4320,"end_statement_char_in_start":243,"end_statement_char_in_end":246},{"body_character":"def non_empty_predicatesef non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        e","children":[],"id":"47","children_ids":[],"type":"method","name":"non_empty_predicates","body":"def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end","line_start":162,"line_end":164,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def non_empty_predicates","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)/","start_statement_matched":"def non_empty_predicates","start_statement_line_start":162,"start_statement_line_end":162,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":164,"end_statement_line_end":164,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":4369,"start_statement_char_start":4369,"start_statement_char_end":4393,"start_statement_char_in_start":0,"start_statement_char_in_end":24,"char_end":4452,"end_statement_char_start":4449,"end_statement_char_end":4452,"end_statement_char_in_start":80,"end_statement_char_in_end":83},{"body_character":"def wrap_sql_literal(node)ef wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        e","children":[{"body_character":" if if ::String === node\n            node = Arel.sql(node)\n          e","children":[],"id":"49","children_ids":[],"type":"statement","name":null,"body":" if ::String === node\n            node = Arel.sql(node)\n          end","line_start":167,"line_end":169,"line_preserve_start_whitespaces":"          ","line_preserve_end_whitespaces":"","start_statement":" if ","end_statement":"end","start_statement_regexp":"/\\s((if)|(case)|(do)|(begin))\\s/","start_statement_matched":" if ","start_statement_line_start":167,"start_statement_line_end":167,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":169,"end_statement_line_end":169,"end_statement_line_in_start":3,"end_statement_line_in_end":3,"char_start":4498,"start_statement_char_start":4498,"start_statement_char_end":4502,"start_statement_char_in_start":0,"start_statement_char_in_end":4,"char_end":4567,"end_statement_char_start":4564,"end_statement_char_end":4567,"end_statement_char_in_start":66,"end_statement_char_in_end":69}],"id":"48","children_ids":["49"],"type":"method","name":"wrap_sql_literal","body":"def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end","line_start":166,"line_end":171,"line_preserve_start_whitespaces":"        ","line_preserve_end_whitespaces":"","start_statement":"def wrap_sql_literal(node)","end_statement":"end","start_statement_regexp":"/def[\\r\\t\\f ]+([A-Za-z0-9_\\.=\\+]+)[\\r\\t\\f ]*\\(([^()]|\\n)*?\\)/","start_statement_matched":"def wrap_sql_literal(node)","start_statement_line_start":166,"start_statement_line_end":166,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":171,"end_statement_line_end":171,"end_statement_line_in_start":6,"end_statement_line_in_end":6,"char_start":4462,"start_statement_char_start":4462,"start_statement_char_end":4488,"start_statement_char_in_start":0,"start_statement_char_in_end":26,"char_end":4621,"end_statement_char_start":4618,"end_statement_char_end":4621,"end_statement_char_in_start":156,"end_statement_char_in_end":159}],"id":"2","children_ids":["3","4","5","6","7","8","9","10","12","19","20","21","22","23","24","25","28","29","31","32","35","37","39","42","44","47","48"],"type":"class","name":"WhereClause","body":"class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end","line_start":3,"line_end":172,"line_preserve_start_whitespaces":"    ","line_preserve_end_whitespaces":"","start_statement":"class WhereClause ","end_statement":"end","start_statement_regexp":"/class[\\r\\t\\f ]+([A-Za-z0-9_]+)[\\r\\t\\f ]?[A-Za-z0-9_\\\\\\r\\t\\f ]*/","start_statement_matched":"class WhereClause ","start_statement_line_start":3,"start_statement_line_end":3,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":172,"end_statement_line_end":172,"end_statement_line_in_start":170,"end_statement_line_in_end":170,"char_start":41,"start_statement_char_start":41,"start_statement_char_end":59,"start_statement_char_in_start":0,"start_statement_char_in_end":18,"char_end":4629,"end_statement_char_start":4626,"end_statement_char_end":4629,"end_statement_char_in_start":4585,"end_statement_char_in_end":4588}],"id":"1","children_ids":["2"],"type":"class","name":"Relation","body":"class Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  end","line_start":2,"line_end":173,"line_preserve_start_whitespaces":"  ","line_preserve_end_whitespaces":"","start_statement":"class Relation","end_statement":"end","start_statement_regexp":"/class[\\r\\t\\f ]+([A-Za-z0-9_]+)[\\r\\t\\f ]?[A-Za-z0-9_\\\\\\r\\t\\f ]*/","start_statement_matched":"class Relation","start_statement_line_start":2,"start_statement_line_end":2,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":173,"end_statement_line_end":173,"end_statement_line_in_start":172,"end_statement_line_in_end":172,"char_start":22,"start_statement_char_start":22,"start_statement_char_end":36,"start_statement_char_in_start":0,"start_statement_char_in_end":14,"char_end":4635,"end_statement_char_start":4632,"end_statement_char_end":4635,"end_statement_char_in_start":4610,"end_statement_char_in_end":4613}],"id":"0","children_ids":["1"],"type":"module","name":"ActiveRecord","body":"module ActiveRecord\n  class Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  end\nend","line_start":1,"line_end":174,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":"module ActiveRecord","end_statement":"end","start_statement_regexp":"/module[\\r\\t\\f ]+([A-Za-z0-9_]+)[\\r\\t\\f ]?[A-Za-z0-9_\\\\\\r\\t\\f ]*/","start_statement_matched":"module ActiveRecord","start_statement_line_start":1,"start_statement_line_end":1,"start_statement_line_in_start":1,"start_statement_line_in_end":1,"end_statement_regexp":"/end/","end_statement_matched":"end","end_statement_line_start":174,"end_statement_line_end":174,"end_statement_line_in_start":174,"end_statement_line_in_end":174,"char_start":0,"start_statement_char_start":0,"start_statement_char_end":19,"start_statement_char_in_start":0,"start_statement_char_in_end":19,"char_end":4639,"end_statement_char_start":4636,"end_statement_char_end":4639,"end_statement_char_in_start":4636,"end_statement_char_in_end":4639}],"id":null,"children_ids":[],"type":"file","name":null,"body":"module ActiveRecord\n  class Relation\n    class WhereClause # :nodoc:\n      attr_reader :binds\n\n      delegate :any?, :empty?, to: :predicates\n\n      def initialize(predicates, binds)\n        @predicates = predicates\n        @binds = binds\n      end\n\n      def +(other)\n        WhereClause.new(\n          predicates + other.predicates,\n          binds + other.binds,\n        )\n      end\n\n      def merge(other)\n        WhereClause.new(\n          predicates_unreferenced_by(other) + other.predicates,\n          non_conflicting_binds(other) + other.binds,\n        )\n      end\n\n      def except(*columns)\n        WhereClause.new(\n          predicates_except(columns),\n          binds_except(columns),\n        )\n      end\n\n      def or(other)\n        if empty?\n          self\n        elsif other.empty?\n          other\n        else\n          WhereClause.new(\n            [ast.or(other.ast)],\n            binds + other.binds\n          )\n        end\n      end\n\n      def to_h(table_name = nil)\n        equalities = predicates.grep(Arel::Nodes::Equality)\n        if table_name\n          equalities = equalities.select do |node|\n            node.left.relation.name == table_name\n          end\n        end\n\n        binds = self.binds.map { |attr| [attr.name, attr.value] }.to_h\n\n        equalities.map { |node|\n          name = node.left.name\n          [name, binds.fetch(name.to_s) {\n            case node.right\n            when Array then node.right.map(&:val)\n            when Arel::Nodes::Casted, Arel::Nodes::Quoted\n              node.right.val\n            end\n          }]\n        }.to_h\n      end\n\n      def ast\n        Arel::Nodes::And.new(predicates_with_wrapped_sql_literals)\n      end\n\n      def ==(other)\n        other.is_a?(WhereClause) &&\n          predicates == other.predicates &&\n          binds == other.binds\n      end\n\n      def invert\n        WhereClause.new(inverted_predicates, binds)\n      end\n\n      def self.empty\n        @empty ||= new([], [])\n      end\n\n      protected\n\n        attr_reader :predicates\n\n        def referenced_columns\n          @referenced_columns ||= begin\n            equality_nodes = predicates.select { |n| equality_node?(n) }\n            Set.new(equality_nodes, &:left)\n          end\n        end\n\n      private\n\n        def predicates_unreferenced_by(other)\n          predicates.reject do |n|\n            equality_node?(n) && other.referenced_columns.include?(n.left)\n          end\n        end\n\n        def equality_node?(node)\n          node.respond_to?(:operator) && node.operator == :==\n        end\n\n        def non_conflicting_binds(other)\n          conflicts = referenced_columns & other.referenced_columns\n          conflicts.map! { |node| node.name.to_s }\n          binds.reject { |attr| conflicts.include?(attr.name) }\n        end\n\n        def inverted_predicates\n          predicates.map { |node| invert_predicate(node) }\n        end\n\n        def invert_predicate(node)\n          case node\n          when NilClass\n            raise ArgumentError, \"Invalid argument for .where.not(), got nil.\"\n          when Arel::Nodes::In\n            Arel::Nodes::NotIn.new(node.left, node.right)\n          when Arel::Nodes::Equality\n            Arel::Nodes::NotEqual.new(node.left, node.right)\n          when String\n            Arel::Nodes::Not.new(Arel::Nodes::SqlLiteral.new(node))\n          else\n            Arel::Nodes::Not.new(node)\n          end\n        end\n\n        def predicates_except(columns)\n          predicates.reject do |node|\n            case node\n            when Arel::Nodes::Between, Arel::Nodes::In, Arel::Nodes::NotIn, Arel::Nodes::Equality, Arel::Nodes::NotEqual, Arel::Nodes::LessThan, Arel::Nodes::LessThanOrEqual, Arel::Nodes::GreaterThan, Arel::Nodes::GreaterThanOrEqual\n              subrelation = (node.left.kind_of?(Arel::Attributes::Attribute) ? node.left : node.right)\n              columns.include?(subrelation.name.to_s)\n            end\n          end\n        end\n\n        def binds_except(columns)\n          binds.reject do |attr|\n            columns.include?(attr.name)\n          end\n        end\n\n        def predicates_with_wrapped_sql_literals\n          non_empty_predicates.map do |node|\n            if Arel::Nodes::Equality === node\n              node\n            else\n              wrap_sql_literal(node)\n            end\n          end\n        end\n\n        ARRAY_WITH_EMPTY_STRING = [\"\"]\n        def non_empty_predicates\n          predicates - ARRAY_WITH_EMPTY_STRING\n        end\n\n        def wrap_sql_literal(node)\n          if ::String === node\n            node = Arel.sql(node)\n          end\n          Arel::Nodes::Grouping.new(node)\n        end\n    end\n  end\nend\n","line_start":1,"line_end":175,"line_preserve_start_whitespaces":"","line_preserve_end_whitespaces":"","start_statement":null,"end_statement":null,"start_statement_regexp":null,"start_statement_matched":null,"start_statement_line_start":null,"start_statement_line_end":null,"start_statement_line_in_start":null,"start_statement_line_in_end":null,"end_statement_regexp":null,"end_statement_matched":null,"end_statement_line_start":null,"end_statement_line_end":null,"end_statement_line_in_start":null,"end_statement_line_in_end":null}